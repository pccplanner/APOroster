<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Roster System (v13.0 - Consolidated Setup)</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 4. Load Firebase SDKs (v10.13.1 - Stable) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            onSnapshot, 
            collection, 
            getDocs,
            deleteDoc,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

        // Set Firebase Log Level for debugging
        setLogLevel('debug');

        // --- Mock Firebase Config (REPLACED by Canvas Globals) ---
        const mockFirebaseConfig = {
          apiKey: "AIzaSyD7EdbBA4e04e6XvxnPgFdqZo_9squYMg0",
          authDomain: "shift-tracker-b7879.firebaseapp.com",
          projectId: "shift-tracker-b7879",
          storageBucket: "shift-tracker-b7879.firebasestorage.app",
          messagingSenderId: "619413261457",
          appId: "1:619413261457:web:71bb4d19745a64aAB20330",
          measurementId: "G-Q0BFJ8SBSY"
        };
        
        // --- Canvas Environment Variables (CRITICAL) ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : mockFirebaseConfig;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Make functions and db available globally
        window.db = db;
        window.auth = auth; 
        
        window.firebase = {
            doc,
            getDoc,
            setDoc,
            onSnapshot,
            collection,
            getDocs,
            deleteDoc,
            signInAnonymously,
            onAuthStateChanged,
            signInWithCustomToken,
            initialAuthToken
        };
    </script>
    
    <style>
        /* --- General Styling --- */
        .highlight-cell {
            background-color: #FDE047; /* yellow-300 */
            border: 2px solid #F59E0B; /* amber-500 */
            color: #000;
            font-weight: bold;
        }
        .dropdown-permanent {
            font-weight: bold;
            color: #1D4ED8; /* blue-700 */
            background-image: linear-gradient(45deg, #EFF6FF 50%, #DBEAFE 50%);
            background-size: 8px 8px;
        }
        .dropdown-buffer {
            font-weight: bold;
            color: #581c87; /* purple-900 */
            background-color: #d8b4fe; /* purple-300 */
        }
        select, input {
            text-align: center !important;
            text-align-last: center !important;
            -moz-text-align-last: center !important;
        }
        
        /* --- Consolidated Setup Card Styles --- */
        .staff-card-scheduled {
            border: 1px solid #10B981; /* emerald-500 */
            background-color: #F0FDF4; /* emerald-50 */
        }
        .staff-card-unscheduled {
            border: 1px solid #F87171; /* red-400 */
            background-color: #FEF2F2; /* red-50 */
        }
        
        /* --- PRINT STYLES (CRITICAL FOR USER REQUEST) --- */
        @media print {
            header, footer, .nav-buttons, .action-buttons, .focus-buttons, .date-selector, .unsaved-changes, .print-hidden, .setup-tools {
                display: none !important;
            }
            @page {
                size: A4 landscape;
                margin: 0.5cm; 
            }
            body { zoom: 80%; }
            .min-h-screen, #root, main, .container {
                min-height: auto !important; padding: 0 !important; margin: 0 auto !important; width: 100% !important; max-width: none !important;
            }
            .shadow-md, .rounded-lg, .border { box-shadow: none !important; border: none !important; border-collapse: collapse !important; }
            .roster-section { break-inside: avoid; margin-bottom: 0.5cm !important; padding: 0 !important; }
            .overflow-x-auto { overflow: visible !important; }
            .min-w-full { width: 100% !important; table-layout: fixed; }
            .min-w-full th:first-child, .min-w-full td:first-child {
                width: 2.4in !important; max-width: 2.4in !important; min-width: 2.4in !important; white-space: normal !important; text-align: left !important; 
            }
            .min-w-full th:first-child, .min-w-full td:first-child span { font-size: 7.5pt !important; }
            .p-1 { padding: 0.1rem !important; }
            .text-xs, .text-sm { font-size: 8pt !important; line-height: 1.1 !important; }
            .sticky { position: static !important; }
            input, select {
                -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important;
                border: 0.5px solid #ccc !important; background-color: transparent !important; text-align: center !important; font-weight: bold; color: #000;
                width: 100% !important; box-sizing: border-box !important;
            }
            .dropdown-permanent, .dropdown-buffer, .highlight-cell {
                background-color: #E0F2FE !important; color: #000 !important; border: 0.5px solid #999 !important; background-image: none !important;
            }
            .bg-gray-100, .bg-gray-50 { background-color: #f7f7f7 !important; }
            .bg-white { background-color: white !important; }
            .highlight-cell { background-color: #FEF3C7 !important; }
            .vp-cell-fix { width: 17% !important; text-align: center !important; padding: 0px !important; margin: 0px !important; }
            .roster-section table td { padding: 0.1rem 0 !important; }
            .roster-section table input.vp-cell-fix, .roster-section table select.vp-cell-fix {
                margin: 0 !important; padding: 1px 1px !important; height: 14px !important; line-height: 1.2 !important; text-align: center !important; width: 100% !important; box-sizing: border-box !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, createContext, useContext } = React;
        const { 
            doc, getDoc, setDoc, onSnapshot, 
            collection, deleteDoc,
            signInAnonymously, onAuthStateChanged, 
            signInWithCustomToken, initialAuthToken
        } = window.firebase;
        const db = window.db;
        const auth = window.auth; 

        // --- Constants ---
        const SECURITY_POSITIONS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        const FOYER_POSITIONS = ["XRAY-VISITOR", "FOYER-OE"];
        const VERTICAL_PROWLER_POSITION = "VERTICAL PROWLER";
        const SENTRY_POSITIONS = ["E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY", "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"];
        const TIME_SLOTS = ["2000Hrs", "2100Hrs", "2200Hrs", "2300Hrs", "2400Hrs", "0100Hrs", "0200Hrs", "0300Hrs", "0400Hrs", "0500Hrs", "0600Hrs", "0700Hrs"];
        const VERTICAL_PROWLER_SLOTS = ["20:30", "23:00", "00:30", "03:00", "04:30", "06:30"];
        const SENTRY_SEQUENCE_KEYS = ["E1", "OE", "P2", "N1", "E3", "P1"];
        const FOYER_ASSIGNMENT_KEYS = ["FOYER 1", "FOYER 2"];
        const SECURITY_ASSIGNMENT_KEYS = ["TEAM LEADER (I/C)", "SECTION I/C"];
        const ASSIGNMENT_KEYS = [...SENTRY_SEQUENCE_KEYS, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS].sort();
        const UNASSIGNED_KEY = "Unassigned";
        const UNFILLED_SLOT = "---";

        const SENTRY_POSITION_SEQUENCES = {
            "E1": ["E1", "OE", "P2", "N1", "E3", "P1"], "PATROL 1": ["P1", "E1", "OE", "P2", "N1", "E3"],
            "E3": ["E3", "P1", "E1", "OE", "P2", "N1"], "N1 (CNB)": ["N1", "E3", "P1", "E1", "OE", "P2"],
            "PATROL 2": ["P2", "N1", "E3", "P1", "E1", "OE"], "OE/ STANDBY": ["OE", "P2", "N1", "E3", "P1", "E1"],
            "PERIMETER PROWLER (1st Half)": ["P1", "E1", "OE", "P2", "N1", "E3"], "PERIMETER PROWLER (2nd Half)": ["P2", "N1", "E3", "P1", "E1", "OE"]
        };
        
        // --- DB Collection Names ---
        const STAFF_POOL_COLLECTION = "staffPool_v7";
        const DAILY_ASSIGNMENTS_COLLECTION = "dailyAssignments_v7";
        const DAILY_ROSTER_COLLECTION = "dailyRosters_v7";
        // Attendance now stores the schedule status for a given day
        const DAILY_ATTENDANCE_COLLECTION = "dailyAttendance_v7"; 

        // --- Helper: Get today's date ---
        const getTodayDate = () => {
            const today = new Date();
            const offset = today.getTimezoneOffset();
            const adjustedToday = new Date(today.getTime() - (offset*60*1000));
            return adjustedToday.toISOString().split('T')[0];
        };

        // --- CRITICAL: Helper to sanitize data for Firestore ---
        const sanitizeForFirestore = (obj) => {
            if (obj === undefined || obj === null) return null;
            if (Array.isArray(obj)) {
                return obj.map(sanitizeForFirestore);
            }
            if (typeof obj === 'object' && obj !== null) {
                const newObj = {};
                Object.keys(obj).forEach(key => {
                    newObj[key] = sanitizeForFirestore(obj[key]);
                });
                return newObj;
            }
            return obj;
        };
        
        // --- React Context for Staff Pool & Attendance ---
        const StaffContext = createContext();
        
        function StaffProvider({ children, selectedDate }) {
            const [staffPool, setStaffPool] = useState([]); 
            const [dailyAttendance, setDailyAttendance] = useState([]); // Array of IDs scheduled for the day
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            
            // 1. Load Staff Pool
            useEffect(() => {
                if (!db) return setError("Database connection failed during staff load.");
                setLoading(true);
                const staffCollectionRef = collection(db, STAFF_POOL_COLLECTION);
                const unsubscribe = onSnapshot(staffCollectionRef, (querySnapshot) => {
                    const pool = [];
                    querySnapshot.forEach(doc => {
                        pool.push({
                            id: doc.data().id,
                            type: doc.data().type || 'permanent'
                        });
                    });
                    setStaffPool(pool.sort((a, b) => a.id.localeCompare(b.id)));
                }, (err) => {
                    console.error("Error fetching staff pool: ", err);
                    setError("Could not load staff pool.");
                });
                return () => unsubscribe();
            }, []);
            
            // 2. Load Daily Attendance for selected date
            useEffect(() => {
                if (!db || !selectedDate) return;
                const docRef = doc(db, DAILY_ATTENDANCE_COLLECTION, selectedDate);
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    const scheduledIds = docSnap.exists() ? docSnap.data().scheduledStaff || [] : [];
                    setDailyAttendance(scheduledIds);
                    setLoading(false);
                }, (err) => {
                    console.error("Error fetching daily attendance: ", err);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [selectedDate]);
            
            const staffTypeMap = useMemo(() => {
                const map = new Map();
                staffPool.forEach(staff => {
                    map.set(staff.id, staff.type);
                });
                return map;
            }, [staffPool]);
            
            // Filtered staff list: only staff marked as scheduled
            const scheduledStaff = useMemo(() => {
                const scheduledSet = new Set(dailyAttendance);
                // Only filter if attendance has been loaded (not in the initial loading state)
                if (loading) return staffPool; 
                
                // If attendance loaded and is empty, it means no one is scheduled
                return staffPool.filter(staff => scheduledSet.has(staff.id));
            }, [staffPool, dailyAttendance, loading]);

            const value = { 
                staffPool, 
                staffTypeMap, 
                loading, 
                error,
                dailyAttendance,
                scheduledStaff
            };
            
            return (
                <StaffContext.Provider value={value}>
                    {children}
                </StaffContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const [view, setView] = useState('roster'); 
            const [userId, setUserId] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [authError, setAuthError] = useState(null);
            const [selectedDate, setSelectedDate] = useState(getTodayDate());

            useEffect(() => {
                if (!auth) {
                    setAuthError("Authentication service is unavailable.");
                    setAuthLoading(false);
                    return;
                }
                
                let isSigningIn = false;
                
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                        setAuthLoading(false);
                    } else if (!isSigningIn) {
                        isSigningIn = true;
                        const signIn = async () => {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                    console.log("Signed in with custom token.");
                                } else {
                                    await signInAnonymously(auth);
                                    console.log("Signed in anonymously.");
                                }
                            } catch (err) {
                                console.error("Authentication error: ", err);
                                setAuthError("Failed to authenticate.");
                            } finally {
                                setAuthLoading(false);
                            }
                        };
                        signIn();
                    }
                });
                
                return () => unsubscribe();
            }, []); 

            if (authLoading) return <div className="p-8 text-center text-xl font-semibold">Connecting...</div>
            if (authError) return <div className="p-8 text-center text-xl font-semibold text-red-600">{authError}</div>
            if (!userId) return <div className="p-8 text-center text-xl font-semibold">Authenticating...</div>

            return (
                <StaffProvider selectedDate={selectedDate}>
                    <div className="min-h-screen">
                        {/* Header: Hidden on Print */}
                        <header className="bg-white shadow-md">
                            <nav className="container mx-auto px-4 sm:px-6 lg:px-8 flex flex-col sm:flex-row justify-between items-center py-4 gap-4">
                                <h1 className="text-2xl font-bold text-blue-600">Direct Assign Roster (v13.0)</h1>
                                <div className="flex space-x-2 nav-buttons">
                                    <NavButton
                                        label="Daily Roster"
                                        isActive={view === 'roster'}
                                        onClick={() => setView('roster')}
                                    />
                                    <NavButton
                                        label="Staff & Roster Setup"
                                        isActive={view === 'settings'}
                                        onClick={() => setView('settings')}
                                    />
                                </div>
                            </nav>
                        </header>
                        
                        {/* Page Content */}
                        <main className="container mx-auto p-0 sm:p-6 lg:px-8">
                            {view === 'roster' && <RosterView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                            {view === 'settings' && <StaffAndRosterSetupView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                        </main>
                        
                        {/* Footer: Hidden on Print */}
                        <footer className="text-center p-4 text-gray-500 text-sm">
                            User ID: <span className="font-mono bg-gray-200 px-1 rounded">{userId}</span>
                        </footer>
                    </div>
                </StaffProvider>
            );
        }

        function NavButton({ label, isActive, onClick }) {
            const baseClasses = "py-2 px-4 rounded-md font-medium text-sm sm:text-base transition-all duration-200";
            const activeClasses = "bg-blue-600 text-white shadow-md";
            const inactiveClasses = "text-gray-600 hover:bg-gray-200";
            return ( <button onClick={onClick} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>{label}</button> );
        }

        // --- View 1: Staff & Roster Setup (Combined and Consolidated) ---
        function StaffAndRosterSetupView({ selectedDate, setSelectedDate }) {
            return (
                <div className="space-y-6">
                    {/* Section 1: Consolidated Staff Pool and Attendance Management */}
                    <ConsolidatedStaffManagement selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                    
                    {/* Section 2 (Original Section 3): Daily Assignment Setup */}
                    <DailySequenceAssignment selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                </div>
            );
        }
        
        // --- NEW CONSOLIDATED COMPONENT ---
        function ConsolidatedStaffManagement({ selectedDate, setSelectedDate }) {
            const { staffPool, dailyAttendance, loading: staffLoading } = useContext(StaffContext);
            const [newStaffId, setNewStaffId] = useState("");
            const [newStaffType, setNewStaffType] = useState("permanent");
            const [localDailyAttendance, setLocalDailyAttendance] = useState([]);
            const [status, setStatus] = useState("idle");
            const [error, setError] = useState(null);
            
            // Sync Firestore attendance data with local state when it changes from the DB
            useEffect(() => {
                setLocalDailyAttendance(dailyAttendance);
                setStatus("idle");
            }, [dailyAttendance, selectedDate]);
            
            const isLocalDataDirty = useMemo(() => {
                if (localDailyAttendance.length !== dailyAttendance.length) return true;
                return localDailyAttendance.some(id => !dailyAttendance.includes(id));
            }, [localDailyAttendance, dailyAttendance]);

            const scheduledSet = useMemo(() => new Set(localDailyAttendance), [localDailyAttendance]);
            
            // --- Pool Management Functions (Unchanged Logic) ---
            const handleAddStaff = async () => {
                const id = newStaffId.trim();
                if (id && !staffPool.find(s => s.id === id)) {
                    try {
                        const staffDocRef = doc(db, STAFF_POOL_COLLECTION, id);
                        await setDoc(staffDocRef, { id: id, type: newStaffType });
                        setNewStaffId("");
                        // Automatically schedule new staff for the current day
                        setLocalDailyAttendance(prev => [...prev, id].sort());
                        setStatus("unsaved");
                    } catch (err) {
                        console.error("Error adding staff: ", err);
                    }
                }
            };
            
            const handleRemoveStaff = async (id) => {
                if (window.confirm(`Are you sure you want to remove staff ID ${id} from the pool? This is permanent.`)) {
                    try {
                        // 1. Remove from staff pool
                        const staffDocRef = doc(db, STAFF_POOL_COLLECTION, id);
                        await deleteDoc(staffDocRef);
                        
                        // 2. Remove from local attendance
                        setLocalDailyAttendance(prev => prev.filter(staffId => staffId !== id));
                        setStatus("unsaved");
                        
                        // NOTE: Assignment cleanup (DailyAssignments) will happen when user clicks Save Assignments
                        
                    } catch (err) {
                        console.error("Error removing staff: ", err);
                    }
                }
            };

            // --- Attendance Management Functions (New Logic) ---
            const handleAttendanceToggle = (staffId) => {
                setStatus("unsaved");
                let newAttendance;
                if (scheduledSet.has(staffId)) {
                    newAttendance = localDailyAttendance.filter(id => id !== staffId);
                } else {
                    newAttendance = [...localDailyAttendance, staffId].sort();
                }
                setLocalDailyAttendance(newAttendance);
            };
            
            const handleUnscheduleAll = () => {
                setLocalDailyAttendance([]); 
                setStatus("unsaved"); 
            };
            
            const handleScheduleAll = () => {
                setLocalDailyAttendance(staffPool.map(s => s.id));
                setStatus("unsaved"); 
            };
            
            const handleSaveAttendance = async () => {
                if (!db) return setError("Database not available.");
                setStatus("saving");
                setError(null);
                try {
                    const docRef = doc(db, DAILY_ATTENDANCE_COLLECTION, selectedDate);
                    await setDoc(docRef, { 
                        scheduledStaff: localDailyAttendance,
                        updatedAt: new Date().toISOString(),
                    });
                    setStatus("saved");
                    // Refetch hook will update dailyAttendance state
                    setTimeout(() => setStatus("idle"), 2000);
                } catch (err) {
                    console.error("Error saving daily attendance: ", err);
                    setError("Failed to save daily attendance.");
                    setStatus("error");
                }
            };
            
            // --- Render Logic ---
            const isLoading = staffLoading && staffPool.length === 0;

            return (
                <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                    <h2 className="text-xl font-bold mb-4 text-gray-800">1. Staff Pool & Daily Attendance Management</h2>
                    
                    <div className="setup-tools">
                        {/* Date Selector */}
                        <div className="mb-4 date-selector flex flex-col sm:flex-row items-start sm:items-center gap-2">
                            <label htmlFor="roster-date-attendance" className="font-medium text-gray-700 text-lg">Select Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-attendance"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>

                        {/* Add Staff Tool */}
                        <div className="flex flex-col sm:flex-row gap-2 mb-6 p-4 border rounded-lg bg-blue-50">
                            <input
                                type="text"
                                value={newStaffId}
                                onChange={(e) => setNewStaffId(e.target.value)}
                                className="flex-grow p-2 border border-gray-300 rounded-md shadow-sm"
                                placeholder="Enter new Staff ID"
                            />
                            <select 
                                value={newStaffType}
                                onChange={(e) => setNewStaffType(e.target.value)}
                                className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                            >
                                <option value="permanent">Permanent</option>
                                <option value="buffer">Buffer</option>
                            </select>
                            <button onClick={handleAddStaff} className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700">Add Staff to Pool</button>
                        </div>
                    </div>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{error}</div>}

                    {isLoading && <p className="text-center p-4">Loading Staff Pool and Attendance...</p>}
                    {!isLoading && (
                        <div className="flex flex-col gap-2 p-4 rounded-lg border border-gray-200">
                             <div className="flex flex-wrap justify-between items-center mb-4 border-b pb-2">
                                <span className="font-bold text-lg text-gray-800">
                                    Scheduled: {localDailyAttendance.length} / {staffPool.length}
                                </span>
                                <div className="flex space-x-2 setup-tools">
                                     <button 
                                        onClick={handleScheduleAll}
                                        disabled={status === 'saving'}
                                        className="py-1 px-3 text-sm bg-emerald-600 text-white rounded-md shadow-md hover:bg-emerald-700 disabled:bg-gray-400"
                                    >
                                        Schedule All
                                    </button>
                                    <button 
                                        onClick={handleUnscheduleAll}
                                        disabled={status === 'saving'}
                                        className="py-1 px-3 text-sm bg-red-600 text-white rounded-md shadow-md hover:bg-red-700 disabled:bg-gray-400"
                                    >
                                        Unschedule All
                                    </button>
                                </div>
                             </div>
                            
                            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3">
                                {staffPool.map(staff => {
                                    const isScheduled = scheduledSet.has(staff.id);
                                    
                                    return (
                                        <div 
                                            key={staff.id}
                                            className={`p-3 rounded-lg shadow-md transition-all flex flex-col items-center relative group ${
                                                isScheduled 
                                                ? 'staff-card-scheduled hover:bg-emerald-200 cursor-pointer' 
                                                : 'staff-card-unscheduled hover:bg-red-200 cursor-pointer'
                                            }`}
                                        >
                                            {/* Top Corner Badge for Type */}
                                            <span className={`absolute top-1 left-1 text-xs font-semibold px-2 py-0.5 rounded-full ${
                                                staff.type === 'buffer' ? 'bg-purple-200 text-purple-800' : 'bg-blue-200 text-blue-800'
                                            }`}>
                                                {staff.type.toUpperCase()}
                                            </span>
                                            
                                            {/* Remove Staff Button */}
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); handleRemoveStaff(staff.id); }} 
                                                className="absolute top-1 right-1 text-red-500 hover:text-red-700 text-lg font-bold opacity-0 group-hover:opacity-100 transition-opacity print-hidden"
                                                title={`Remove ${staff.id} from Pool`}
                                            >
                                                &times;
                                            </button>

                                            {/* Main Content (Clickable Area for Attendance) */}
                                            <div 
                                                onClick={() => handleAttendanceToggle(staff.id)}
                                                className="w-full text-center pt-4 pb-1"
                                            >
                                                <span className="text-xl font-extrabold text-gray-900">{staff.id}</span>
                                                <p className={`text-xs font-bold mt-1 ${
                                                    isScheduled ? 'text-emerald-700' : 'text-red-700'
                                                }`}>
                                                    {isScheduled ? 'SCHEDULED' : 'NOT SCHEDULED'}
                                                </p>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    
                    <div className="flex justify-end items-center gap-4 mt-6 border-t pt-4 action-buttons">
                        {status === 'saved' && <span className="text-green-600">Attendance Saved!</span>}
                        {status === 'error' && <span className="text-red-600">Save failed!</span>}
                        {isLocalDataDirty && <span className="text-yellow-700">Unsaved attendance changes.</span>}
                        <button
                            onClick={handleSaveAttendance}
                            disabled={status === 'saving' || isLoading || !isLocalDataDirty}
                            className="py-2 px-6 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                        >
                            {status === 'saving' ? "Saving..." : "Save Daily Attendance"}
                        </button>
                    </div>
                </div>
            );
        }

        
        // --- Sub-component for Daily Sequence Assignment (Original Section 3, now Section 2) ---
        function DailySequenceAssignment({ selectedDate, setSelectedDate }) {
            const { scheduledStaff: allStaff, staffTypeMap, loading: staffLoading, dailyAttendance } = useContext(StaffContext); 
            const [sequenceMap, setSequenceMap] = useState({});
            const [locationBufferMap, setLocationBufferMap] = useState({});
            const [loading, setLoading] = useState(true);
            const [status, setStatus] = useState("idle");
            const [error, setError] = useState(null);

            const allAssignmentKeys = useMemo(() => ASSIGNMENT_KEYS, []);
            
            const overrideLocations = useMemo(() => [
                "E3", "N1 (CNB)", "PATROL 1", "PATROL 2", VERTICAL_PROWLER_POSITION
            ], []);
            
            const bufferStaff = useMemo(() => allStaff.filter(s => s.type === 'buffer'), [allStaff]);

            useEffect(() => {
                if (!selectedDate || !db) return;
                setLoading(true);
                const docRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    
                    const defaultMap = {};
                    allAssignmentKeys.forEach(key => defaultMap[key] = []); 
                    const defaultLocMap = {};

                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        const loadedMap = data.sequenceMap || {};
                        Object.keys(loadedMap).forEach(key => {
                            if (allAssignmentKeys.includes(key)) { 
                                let staffIds = Array.isArray(loadedMap[key]) ? loadedMap[key] : (loadedMap[key] ? [loadedMap[key]] : []);
                                // CRITICAL: Filter loaded assignments to only include staff currently marked as scheduled
                                const scheduledStaffIds = new Set(dailyAttendance);
                                defaultMap[key] = staffIds.filter(id => scheduledStaffIds.has(id));
                            }
                        });
                        setSequenceMap(defaultMap);
                        setLocationBufferMap(data.locationBufferMap || {});
                    } else {
                        setSequenceMap(defaultMap);
                        setLocationBufferMap({});
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading daily assignments: ", err);
                    setError("Failed to load daily assignments.");
                    setLoading(false);
                });
                
                return () => unsubscribe();
            }, [selectedDate, allAssignmentKeys, dailyAttendance]);

            const staffToSequenceMap = useMemo(() => {
                const map = {};
                for (const key of allAssignmentKeys) {
                    let staffIds = sequenceMap[key]; 
                    if (staffIds) {
                        if (!Array.isArray(staffIds)) staffIds = [staffIds];
                        staffIds.forEach(staffId => {
                            if (map[staffId]) {
                                map[staffId] = `${map[staffId]}, ${key}`;
                            } else {
                                map[staffId] = key;
                            }
                        });
                    }
                }
                return map;
            }, [sequenceMap, allAssignmentKeys]);

            const handleSequenceChange = (keyToAssign, staffId) => {
                setStatus("unsaved");
                const newMap = { ...sequenceMap };
                const staffType = staffTypeMap.get(staffId);
                
                if (staffType !== 'buffer') {
                     allAssignmentKeys.forEach(key => {
                         if (newMap[key] && newMap[key].includes(staffId)) {
                             newMap[key] = newMap[key].filter(id => id !== staffId);
                         }
                     });
                }

                const currentIdsInSlot = newMap[keyToAssign] || [];
                
                if (!currentIdsInSlot.includes(staffId)) {
                    newMap[keyToAssign] = [...currentIdsInSlot, staffId];
                }
                
                setSequenceMap(newMap);
            };
            
            const handleLocationBufferChange = (location, staffId) => {
                setStatus("unsaved");
                const newMap = { ...locationBufferMap };
                if (staffId === "") {
                    delete newMap[location];
                } else {
                    newMap[location] = staffId;
                }
                setLocationBufferMap(newMap);
            };

            const handleUnassign = (staffId) => {
                setStatus("unsaved");
                const newMap = { ...sequenceMap };
                
                allAssignmentKeys.forEach(key => {
                     if (newMap[key] && newMap[key].includes(staffId)) {
                         newMap[key] = newMap[key].filter(id => id !== staffId);
                     }
                });
                
                setSequenceMap(newMap);
            };
            
            const handleClearAll = () => {
                if (window.confirm("Are you sure you want to CLEAR ALL assignments for this date? \n\nThis will remove all current selections. You will need to click 'Save' to persist this change.")) {
                    const emptyMap = {};
                    allAssignmentKeys.forEach(key => emptyMap[key] = []);
                    setSequenceMap(emptyMap);
                    setLocationBufferMap({});
                    setStatus("unsaved"); 
                }
            };

            const handleSave = async () => {
                if (!db) return setError("Database not available.");
                setStatus("saving");
                setError(null);
                try {
                    const docRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                    
                    // Filter assignments again before saving to ensure only scheduled staff are in the database
                    const scheduledStaffIds = new Set(allStaff.map(s => s.id));
                    const cleanedSequenceMap = {};
                    Object.entries(sequenceMap).forEach(([key, staffIds]) => {
                        cleanedSequenceMap[key] = staffIds.filter(id => scheduledStaffIds.has(id));
                    });
                    
                    const cleanedLocationBufferMap = {};
                    Object.entries(locationBufferMap).forEach(([key, staffId]) => {
                        if (scheduledStaffIds.has(staffId)) {
                             cleanedLocationBufferMap[key] = staffId;
                        }
                    });
                    
                    await setDoc(docRef, { 
                        sequenceMap: cleanedSequenceMap,
                        locationBufferMap: cleanedLocationBufferMap 
                    });
                    
                    setSequenceMap(cleanedSequenceMap);
                    setLocationBufferMap(cleanedLocationBufferMap);
                    
                    setStatus("saved");
                    setTimeout(() => setStatus("idle"), 2000);
                } catch (err) {
                    console.error("Error saving daily setup: ", err);
                    setError("Failed to save daily setup.");
                    setStatus("error");
                }
            };
            
            const isLoading = staffLoading || loading;
            const isDirty = status === 'unsaved';

            return (
                <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                    <h2 className="text-xl font-bold mb-4 text-gray-800">2. Daily Assignment Setup</h2>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{error}</div>}
                    
                    <p className="text-gray-600 mb-4 text-sm font-bold bg-green-50 p-3 rounded-md border border-green-300">
                        Showing only **{allStaff.length}** staff members who are **SCHEDULED** for {selectedDate} (managed in Section 1).
                    </p>
                    
                    {isLoading && <p>Loading...</p>}
                    {!isLoading && (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {allStaff.length === 0 && <p className="text-gray-500 col-span-full">No staff are scheduled for this date (Check Section 1).</p>}
                            {allStaff.map(staff => {
                                const assignedSequence = staffToSequenceMap[staff.id] || "";
                                const staffType = staff.type;
                                
                                const isSentryAssignment = SENTRY_SEQUENCE_KEYS.some(k => assignedSequence.includes(k));
                                const isFoyerAssignment = FOYER_ASSIGNMENT_KEYS.some(k => assignedSequence.includes(k));
                                const isSecurityAssignment = SECURITY_ASSIGNMENT_KEYS.some(k => assignedSequence.includes(k));
                                
                                let colorClass = 'bg-white';
                                if (staffType === 'buffer' && assignedSequence) {
                                    colorClass = 'bg-purple-100 border-purple-300';
                                }
                                else if (isSentryAssignment) colorClass = 'bg-blue-100 border-blue-300';
                                else if (isFoyerAssignment) colorClass = 'bg-green-100 border-green-300';
                                else if (isSecurityAssignment) colorClass = 'bg-orange-100 border-orange-300';

                                const isMultiple = assignedSequence.includes(',');

                                return (
                                    <div 
                                        key={staff.id}
                                        className={`p-4 border rounded-lg flex items-center justify-between transition-all ${colorClass}`}
                                    >
                                        <div className="flex items-center gap-2">
                                            <span className="text-lg font-medium text-gray-900">{staff.id}</span>
                                            {staff.type === 'buffer' && (
                                                <span className="text-xs font-semibold px-2 py-0.5 rounded-full bg-purple-200 text-purple-800">
                                                    {staff.type}
                                                </span>
                                            )}
                                        </div>
                                        <select
                                            value={assignedSequence}
                                            onChange={(e) => {
                                                const newKey = e.target.value;
                                                if (newKey === "") {
                                                    handleUnassign(staff.id);
                                                } else {
                                                    handleSequenceChange(newKey, staff.id);
                                                }
                                            }}
                                            className="p-2 border border-gray-300 rounded-md shadow-sm w-40 truncate"
                                        >
                                            <option value="">{UNASSIGNED_KEY}</option>
                                            
                                            {isMultiple && (
                                                <option value={assignedSequence} disabled>{assignedSequence} (Multiple)</option>
                                            )}

                                            {allAssignmentKeys.map(key => {
                                                const staffIdsInSlot = sequenceMap[key] || [];
                                                const isThisStaffInSlot = staffIdsInSlot.includes(staff.id);
                                                
                                                let isDisabled = false;
                                                const currentScheduledStaffInSlot = staffIdsInSlot.filter(id => allStaff.some(s => s.id === id));
                                                
                                                if (!isThisStaffInSlot && currentScheduledStaffInSlot.length > 0) {
                                                    const typesInSlot = currentScheduledStaffInSlot.map(id => staffTypeMap.get(id));
                                                    
                                                    if (staff.type === 'permanent' || !staff.type) {
                                                        isDisabled = true;
                                                    } else if (staff.type === 'buffer') {
                                                        if (typesInSlot.includes('buffer')) {
                                                            isDisabled = true;
                                                        }
                                                        if (currentScheduledStaffInSlot.length >= 2) {
                                                             isDisabled = true;
                                                        }
                                                    }
                                                }
                                                
                                                return (
                                                    <option key={key} value={key} disabled={isDisabled} className="truncate">
                                                        {key} {currentScheduledStaffInSlot.length > 0 ? `(taken by ${currentScheduledStaffInSlot.join(', ')})` : ""}
                                                    </option>
                                                );
                                            })}
                                        </select>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                    
                    <div className="mt-8 border-t pt-6">
                        <h3 className="text-lg font-bold mb-4 text-gray-800">3. Buffer Location Override (Whole Shift)</h3>
                        <p className="text-gray-600 mb-4 text-sm">
                            Select a Buffer staff (from the scheduled list) to cover an entire location (Row) for the whole night. 
                        </p>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 bg-gray-50 p-4 rounded-lg border">
                             {overrideLocations.map(loc => (
                                 <div key={loc} className="flex flex-col gap-1">
                                     <label className="text-xs font-bold text-gray-600 uppercase">{loc}</label>
                                     <select
                                        value={locationBufferMap[loc] || ""}
                                        onChange={(e) => handleLocationBufferChange(loc, e.target.value)}
                                        className={`p-2 border border-gray-300 rounded-md text-sm ${locationBufferMap[loc] ? 'bg-purple-100 border-purple-400 text-purple-900 font-bold' : 'bg-white'}`}
                                     >
                                         <option value="">-- No Buffer Override --</option>
                                         {bufferStaff.map(b => (
                                             <option key={b.id} value={b.id}>{b.id}</option>
                                         ))}
                                     </select>
                                 </div>
                             ))}
                        </div>
                    </div>
                    
                    <div className="flex justify-end items-center gap-4 mt-6 border-t pt-4 action-buttons">
                        <button
                            onClick={handleClearAll}
                            disabled={status === 'saving' || isLoading}
                            className="py-2 px-4 bg-red-500 text-white rounded-md shadow-md font-medium hover:bg-red-600 disabled:bg-gray-400"
                        >
                            Clear All
                        </button>

                        <div className="flex items-center gap-4">
                            {status === 'saved' && <span className="text-green-600">Assignments Saved!</span>}
                            {status === 'error' && <span className="text-red-600">Save failed!</span>}
                            {isDirty && <span className="text-yellow-700">Unsaved changes.</span>}
                            <button
                                onClick={handleSave}
                                disabled={status === 'saving' || isLoading || !isDirty}
                                className="py-2 px-6 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                            >
                                {status === 'saving' ? "Saving..." : "Save Daily Assignments"}
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // --- View 2: Roster View (Sequence Logic - UNCHANGED) ---
        function RosterView({ selectedDate, setSelectedDate }) {
            const { staffTypeMap } = useContext(StaffContext);
            const [rosterData, setRosterData] = useState(null);
            const [dailyAssignments, setDailyAssignments] = useState(null); 
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [isDirty, setIsDirty] = useState(false);
            
            const [highlightedId, setHighlightedId] = useState(null);
            const [focusView, setFocusView] = useState('all');
            
            const handlePrint = () => {
                window.print();
            };
            
            useEffect(() => {
                if (!selectedDate || !db) return;
                setLoading(true);
                setError(null);
                setIsDirty(false);
                setHighlightedId(null);
                setFocusView('all');

                const assignmentsDocRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubAssignments = onSnapshot(assignmentsDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setDailyAssignments(docSnap.data());
                    } else {
                        setDailyAssignments(null);
                    }
                }, (err) => {
                    console.error("Error loading assignments: ", err);
                    setError("Failed to load daily assignments.");
                });

                const rosterDocRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                const unsubRoster = onSnapshot(rosterDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const loadedGrid = docSnap.data().rosterGrid || {};
                        const newRosterData = {};
                        Object.keys(loadedGrid).forEach(pos => {
                            if(Array.isArray(loadedGrid[pos])) {
                                newRosterData[pos] = loadedGrid[pos].map(cell => {
                                    if (typeof cell === 'string' || !cell) {
                                        return { value: cell || "", isAutomated: false }; 
                                    }
                                    return cell;
                                });
                            }
                        });
                        setRosterData(newRosterData);
                    } else {
                        setRosterData(null);
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading roster: ", err);
                    setError("Failed to load roster data.");
                    setLoading(false);
                });
                
                return () => {
                    unsubAssignments();
                    unsubRoster();
                };
            }, [selectedDate]);
            
            const manualStandbyRows = useMemo(() => {
                if (!rosterData) { return []; }
                return Object.keys(rosterData)
                    .filter(key => key.startsWith("OE/ STANDBY-"))
                    .sort(); 
            }, [rosterData]);
            
            const sentryRowsToRender = useMemo(() => {
                 const sentryRows = [...SENTRY_POSITIONS];
                 const standbyRowIndex = sentryRows.indexOf("OE/ STANDBY");
                 if(standbyRowIndex > -1) {
                     sentryRows.splice(standbyRowIndex + 1, 0, ...manualStandbyRows);
                 }
                 return sentryRows;
            }, [manualStandbyRows]);


            const handleGenerateRoster = async (isReset = false) => {
                setLoading(true);
                setError(null);
                
                if (!db) { setError("Database not available."); setLoading(false); return; }
                
                if (!dailyAssignments || !dailyAssignments.sequenceMap || !staffTypeMap || staffTypeMap.size === 0) {
                    setError("No assignments or staff types found. Please check Setup and wait for data.");
                    setLoading(false);
                    return;
                }
                
                try {
                    const sequenceMap = dailyAssignments.sequenceMap;
                    const locationBufferMap = dailyAssignments.locationBufferMap || {};
                    
                    const newRosterGrid = (rosterData && !isReset) ? { ...rosterData } : {};
                    
                    // --- 1. SENTRY DEPLOYMENT ---
                    SENTRY_POSITIONS.forEach(pos => {
                        const positionRoster = [];
                        const letterSequence = SENTRY_POSITION_SEQUENCES[pos]; 
                        
                        if (letterSequence) { 
                            for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                const sequenceKey = letterSequence[timeIndex % 6];
                                
                                let idsInSlot = sequenceMap[sequenceKey];
                                if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                                const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                                const bufferStaff = idsInSlot.find(id => staffTypeMap.get(id) === 'buffer');
                                
                                const oldCellData = (newRosterGrid[pos] && newRosterGrid[pos][timeIndex]) ? newRosterGrid[pos][timeIndex] : {};
                                
                                if (bufferStaff && permanentStaff !== UNFILLED_SLOT) {
                                    positionRoster.push({
                                        isAutomated: true, permanent: permanentStaff, buffer: bufferStaff,
                                        value: (oldCellData.value === permanentStaff || oldCellData.value === bufferStaff) ? oldCellData.value : permanentStaff,
                                        isPair: true
                                    });
                                } else {
                                    const onlyStaff = idsInSlot[0] || UNFILLED_SLOT;
                                    positionRoster.push({
                                        isAutomated: true, permanent: permanentStaff, buffer: bufferStaff || null,
                                        value: onlyStaff, isPair: false
                                    });
                                }
                            }
                            newRosterGrid[pos] = positionRoster;
                        }
                    });

                    // --- 2. FOYER DEPLOYMENT ---
                    let foyer1_ids = sequenceMap["FOYER 1"];
                    if (!Array.isArray(foyer1_ids)) foyer1_ids = foyer1_ids ? [foyer1_ids] : [];
                    let foyer2_ids = sequenceMap["FOYER 2"];
                    if (!Array.isArray(foyer2_ids)) foyer2_ids = foyer2_ids ? [foyer2_ids] : [];

                    const staffA_perm = foyer1_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffA_buff = foyer1_ids.find(id => staffTypeMap.get(id) === 'buffer');
                    const staffB_perm = foyer2_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffB_buff = foyer2_ids.find(id => staffTypeMap.get(id) === 'buffer');

                    const xraySequence = [];
                    const foyerOESequence = [];
                    
                    for (let i = 0; i < 12; i++) {
                        const isSlotA = !((i >= 3 && i <= 5) || (i >= 9));
                        
                        const permanentStaffA = isSlotA ? staffA_perm : staffB_perm;
                        const bufferStaffA = isSlotA ? staffA_buff : staffB_buff;
                        const permanentStaffB = isSlotA ? staffB_perm : staffA_perm;
                        const bufferStaffB = isSlotA ? staffB_buff : staffA_buff;
                        
                        const isPairA = bufferStaffA && permanentStaffA !== UNFILLED_SLOT;
                        const isPairB = bufferStaffB && permanentStaffB !== UNFILLED_SLOT;

                        const oldXrayCell = (newRosterGrid["XRAY-VISITOR"] && newRosterGrid["XRAY-VISITOR"][i]) ? newRosterGrid["XRAY-VISITOR"][i] : {};
                        const oldOECell = (newRosterGrid["FOYER-OE"] && newRosterGrid["FOYER-OE"][i]) ? newRosterGrid["FOYER-OE"][i] : {};
                        
                        if (isPairA) {
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA, value: (oldXrayCell.value === permanentStaffA || oldXrayCell.value === bufferStaffA) ? oldXrayCell.value : permanentStaffA, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffA !== UNFILLED_SLOT ? permanentStaffA : (bufferStaffA || UNFILLED_SLOT);
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA || null, value: onlyStaff, isPair: false });
                        }
                        
                        if (isPairB) {
                             foyerOESequence.push({ isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB, value: (oldOECell.value === permanentStaffB || oldOECell.value === bufferStaffB) ? oldOECell.value : permanentStaffB, isPair: true });
                        } else {
                            const onlyStaff = permanentStaffB !== UNFILLED_SLOT ? permanentStaffB : (bufferStaffB || UNFILLED_SLOT);
                            foyerOESequence.push({ isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB || null, value: onlyStaff, isPair: false });
                        }
                    }

                    // --- 6-SLOT Vertical Prowler ---
                    const existingProwlerData = newRosterGrid[VERTICAL_PROWLER_POSITION] || [];
                    const verticalProwlerSequence = [
                        foyerOESequence[0],  foyerOESequence[2], foyerOESequence[4], foyerOESequence[6], foyerOESequence[8], foyerOESequence[10]
                    ];
                    
                    [0, 2, 4, 6, 8, 10].forEach(i => {
                        foyerOESequence[i] = { ...foyerOESequence[i], value: UNFILLED_SLOT, isPair: false };
                    });
                    
                    newRosterGrid["XRAY-VISITOR"] = xraySequence;
                    newRosterGrid["FOYER-OE"] = foyerOESequence;
                    
                    const vpManualIndex = 2;
                    if (existingProwlerData[vpManualIndex] && !existingProwlerData[vpManualIndex].isAutomated) {
                        verticalProwlerSequence[vpManualIndex] = existingProwlerData[vpManualIndex];
                    }

                    newRosterGrid[VERTICAL_PROWLER_POSITION] = verticalProwlerSequence.map(cell => ({...cell, isAutomated: true})); 


                    // --- 3. SECURITY CONTROL OFFICE ---
                    let leaderIds = sequenceMap["TEAM LEADER (I/C)"];
                    if (!Array.isArray(leaderIds)) leaderIds = leaderIds ? [leaderIds] : [];
                    let icIds = sequenceMap["SECTION I/C"];
                    if (!Array.isArray(icIds)) icIds = icIds ? [icIds] : [];

                    const teamLeaderId = leaderIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const sectionIcId = icIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const bufferLeader = leaderIds.find(id => staffTypeMap.get(id) === 'buffer');
                    const bufferIc = icIds.find(id => staffTypeMap.get(id) === 'buffer');
                    
                    const isPairLeader = bufferLeader && teamLeaderId !== UNFILLED_SLOT;
                    const isPairIc = bufferIc && sectionIcId !== UNFILLED_SLOT;
                    
                    newRosterGrid["TEAM LEADER (I/C)"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["TEAM LEADER (I/C)"] && newRosterGrid["TEAM LEADER (I/C)"][i]) ? newRosterGrid["TEAM LEADER (I/C)"][i] : {};
                        if (isPairLeader) {
                            return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader, value: (oldCell.value === teamLeaderId || oldCell.value === bufferLeader) ? oldCell.value : teamLeaderId, isPair: true };
                        }
                        const onlyStaff = teamLeaderId !== UNFILLED_SLOT ? teamLeaderId : (bufferLeader || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader || null, value: onlyStaff, isPair: false };
                    });
                    newRosterGrid["SECTION I/C"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["SECTION I/C"] && newRosterGrid["SECTION I/C"][i]) ? newRosterGrid["SECTION I/C"][i] : {};
                        if (isPairIc) {
                            return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc, value: (oldCell.value === sectionIcId || oldCell.value === bufferIc) ? oldCell.value : sectionIcId, isPair: true };
                        }
                        const onlyStaff = sectionIcId !== UNFILLED_SLOT ? sectionIcId : (bufferIc || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc || null, value: onlyStaff, isPair: false };
                    });
                    
                    // --- 4. APPLY LOCATION BUFFER OVERRIDES ---
                    if (locationBufferMap && Object.keys(locationBufferMap).length > 0) {
                        Object.entries(locationBufferMap).forEach(([location, bufferId]) => {
                             if (newRosterGrid[location]) {
                                 newRosterGrid[location] = newRosterGrid[location].map((cell, index) => {
                                     const permanentStaff = cell.permanent || (cell.value !== bufferId ? cell.value : UNFILLED_SLOT);
                                     
                                     if (permanentStaff !== UNFILLED_SLOT && permanentStaff !== "") {
                                         return { ...cell, permanent: permanentStaff, buffer: bufferId, isPair: true, isAutomated: true, value: permanentStaff };
                                     } else {
                                         return { ...cell, permanent: UNFILLED_SLOT, buffer: bufferId, isPair: false, value: bufferId, isAutomated: true };
                                     }
                                 });
                             }
                        });
                    }
                    
                    const finalRosterGrid = sanitizeForFirestore(newRosterGrid);

                    const docRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalRosterGrid, updatedAt: new Date().toISOString() });
                    
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                         setRosterData(docSnap.data().rosterGrid || {});
                    }
                    
                    setIsDirty(false);
                    setLoading(false);
                    
                } catch (err) {
                    console.error("Error generating roster:", err);
                    setError("Failed to generate roster. Check console and security rules.");
                    setLoading(false);
                }
            };
            
            const handleSaveChanges = async () => {
                if (!rosterData || !isDirty) return;
                if (!db) return setError("Database not available.");
                setLoading(true);
                setError(null);
                try {
                    const cleanRosterData = { ...rosterData };
                    const allKeys = Object.keys(cleanRosterData);
                    
                    const existingRows = [
                        ...SECURITY_POSITIONS, ...FOYER_POSITIONS, VERTICAL_PROWLER_POSITION, ...SENTRY_POSITIONS, ...manualStandbyRows
                    ];
                    
                    allKeys.forEach(key => {
                        if (!existingRows.includes(key) && key.startsWith("OE/ STANDBY-")) {
                           delete cleanRosterData[key];
                        }
                    });

                    const finalCleanData = sanitizeForFirestore(cleanRosterData);

                    const docRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                    await setDoc(docRef, { rosterGrid: finalCleanData, updatedAt: new Date().toISOString() });
                    setIsDirty(false);
                    setLoading(false);
                } catch (err) {
                    console.error("Error saving changes: ", err);
                    setError("Failed to save changes.");
                    setLoading(false);
                }
            };

            const handleCellChange = (position, timeIndex, newValue) => {
                setRosterData(prevRoster => {
                    const newRoster = { ...prevRoster };
                    
                    if (!newRoster[position]) {
                        newRoster[position] = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                    }
                    if (!newRoster[position][timeIndex]) {
                         newRoster[position][timeIndex] = { value: "", isAutomated: false };
                    }
                    
                    const cell = newRoster[position][timeIndex];
                    const oldValue = cell.value;
                    
                    newRoster[position][timeIndex] = { ...cell, value: newValue };
                    
                    const permanentId = cell.permanent;
                    const bufferId = cell.buffer;
                    
                    if (cell.isPair && newValue === bufferId && oldValue === permanentId) {
                        placeDisplacedStaff(newRoster, permanentId, timeIndex);
                    }
                    
                    if (cell.isPair && newValue === permanentId && oldValue === bufferId) {
                        removeDisplacedStaff(newRoster, permanentId, timeIndex);
                    }

                    return newRoster;
                });
                setIsDirty(true);
            };
            
            const placeDisplacedStaff = (roster, staffId, timeIndex) => {
                const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                allRows.sort((a, b) => {
                    if (a === "OE/ STANDBY") return -1;
                    if (b === "OE/ STANDBY") return 1;
                    const numA = parseInt(a.split('-')[1] || 999);
                    const numB = parseInt(b.split('-')[1] || 999);
                    return numA - numB;
                });
                
                for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                        const cell = row[timeIndex];
                        if (!cell.value || cell.value === UNFILLED_SLOT || cell.value === "") {
                            if (rowName === "OE/ STANDBY") {
                                roster[rowName][timeIndex] = { ...cell, value: staffId, isDisplaced: true };
                            } else {
                                roster[rowName][timeIndex] = { value: staffId, isAutomated: false };
                            }
                            return;
                        }
                    }
                }
                
                let nextNum = 2;
                while (roster[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                const newRow = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                newRow[timeIndex] = { value: staffId, isAutomated: false };
                roster[newRowName] = newRow;
            };

            const removeDisplacedStaff = (roster, staffId, timeIndex) => {
                 const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                 
                 for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                         const cell = row[timeIndex];
                         if (cell.value === staffId) {
                             if (rowName === "OE/ STANDBY") {
                                roster[rowName][timeIndex] = { ...cell, value: cell.permanent || UNFILLED_SLOT, isDisplaced: false };
                            } else {
                                roster[rowName][timeIndex] = { ...cell, value: "" };
                            }
                            return;
                        }
                    }
                 }
            };

            
            const handleCellClick = (value) => {
                if (!value || value === UNFILLED_SLOT) {
                    setHighlightedId(null);
                    return;
                }
                if (value === highlightedId) {
                    setHighlightedId(null);
                } else {
                    setHighlightedId(value);
                }
            };
            
            const handleAddStandbyRow = () => {
                let nextNum = 2;
                while (rosterData[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                setRosterData(prevData => ({
                    ...prevData,
                    [newRowName]: Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }))
                }));
                setIsDirty(true);
            };

            const handleRemoveStandbyRow = (rowName) => {
                if (window.confirm(`Are you sure you want to remove the row "${rowName}"?`)) {
                    setRosterData(prevData => {
                        const newData = { ...prevData };
                        delete newData[rowName]; 
                        return newData;
                    });
                    setIsDirty(true);
                }
            };
            
            const renderTableBody = (positions) => {
                return (
                    <tbody className="bg-white divide-y divide-gray-200">
                        {positions.map(pos => {
                            const isProwlerRow = pos.startsWith("PERIMETER PROWLER");
                            const isManualStandbyRow = pos.startsWith("OE/ STANDBY-");
                            
                            let displayName = pos;
                            if (focusView === 'sentry') {
                                if (pos === "PERIMETER PROWLER (1st Half)") { displayName = "1st Half"; } 
                                else if (pos === "PERIMETER PROWLER (2nd Half)") { displayName = "2nd Half"; } 
                                else if (pos === "PATROL 1") { displayName = "P1"; } 
                                else if (pos === "PATROL 2") { displayName = "P2"; } 
                                else if (pos === "N1 (CNB)") { displayName = "N1"; } 
                                else if (pos === "OE/ STANDBY") { displayName = "OE"; } 
                                else if (pos.startsWith("OE/ STANDBY-")) { displayName = pos.replace("OE/ STANDBY", "OE"); }
                            }
                            
                            return (
                                <tr key={pos} className={`${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'} hover:bg-gray-200`}>
                                    
                                    <td className={`sticky left-0 p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r ${isProwlerRow ? 'bg-gray-100' : isManualStandbyRow ? 'bg-purple-50' : 'bg-white'}`}>
                                        <div className="flex items-center justify-between">
                                            <span>{displayName}</span>
                                            
                                            {pos === "OE/ STANDBY" && (
                                                <button onClick={handleAddStandbyRow} className="ml-2 w-5 h-5 flex items-center justify-center bg-green-500 text-white rounded-full font-bold hover:bg-green-600 print-hidden" title="Add manual standby row"> + </button>
                                            )}
                                            
                                            {isManualStandbyRow && (
                                                <button onClick={() => handleRemoveStandbyRow(pos)} className="ml-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white rounded-full font-bold hover:bg-red-700 print-hidden" title={`Remove row ${pos}`}> - </button>
                                            )}
                                        </div>
                                    </td>
                                    
                                    {TIME_SLOTS.map((time, index) => {
                                        const cell = (rosterData[pos] && rosterData[pos][index]) ? rosterData[pos][index] : { value: "", isAutomated: isManualStandbyRow ? false : true };
                                        const value = cell.value;
                                        const isAutomated = cell.isAutomated;
                                        const isPair = cell.isPair;
                                        
                                        const isMissing = isAutomated && value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";

                                        const getCellClasses = () => {
                                            let baseClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                            if (isHighlighted) { return baseClasses + " highlight-cell"; }
                                            if (isMissing) { return baseClasses + " bg-yellow-100 text-yellow-800 font-bold"; }
                                            if (isManualStandbyRow) { return baseClasses + " bg-purple-50"; }
                                            if (isPair) {
                                                if (value === cell.buffer) { return baseClasses + " dropdown-buffer"; }
                                                return baseClasses + " dropdown-permanent";
                                            }
                                            if (isAutomated) {
                                                return baseClasses + (isProwlerRow ? ' bg-gray-100 text-gray-700' : ' bg-gray-50 text-gray-700');
                                            }
                                            return baseClasses + " bg-white";
                                        };
                                        
                                        if (isPair) {
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={getCellClasses()}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={getCellClasses()}
                                                    placeholder="ID"
                                                    readOnly={isAutomated && !isManualStandbyRow}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            );
                        })}
                    </tbody>
                );
            };

            const renderTableHeader = (customSlots = TIME_SLOTS) => (
                <thead className="bg-gray-100">
                    <tr>
                        <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                        {customSlots.map(time => (
                            <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap">{time}</th>
                        ))}
                    </tr>
                </thead>
            );

            const renderVerticalProwlerTable = (controlRoomStaff = []) => (
                <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-100">
                            <tr>
                                <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                                {VERTICAL_PROWLER_SLOTS.map(time => (
                                    <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap vp-cell-fix">{time}</th>
                                ))}
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            <tr className="hover:bg-gray-50">
                                <td className="sticky left-0 bg-white p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r">{VERTICAL_PROWLER_POSITION}</td>
                                {VERTICAL_PROWLER_SLOTS.map((time, index) => {
                                    const cell = (rosterData[VERTICAL_PROWLER_POSITION] && rosterData[VERTICAL_PROWLER_POSITION][index]) ? rosterData[VERTICAL_PROWLER_POSITION][index] : { value: "", isAutomated: false };
                                    const value = cell.value;
                                    const isMissing = value === UNFILLED_SLOT;
                                    const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                    const isPair = cell.isPair;
                                    const isAutomated = cell.isAutomated;

                                    let baseClasses = `w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center vp-cell-fix`;
                                    
                                    if (index === 2) { 
                                        let selectClasses = baseClasses;
                                        if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                        else if (isMissing) { selectClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                        else { selectClasses += " bg-white"; }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <select
                                                    value={value}
                                                    onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={selectClasses}
                                                >
                                                    <option value={UNFILLED_SLOT}>{UNFILLED_SLOT}</option>
                                                    {[...new Set(controlRoomStaff)].map(id => (
                                                        <option key={id} value={id}>{id}</option>
                                                    ))}
                                                    {value && value !== UNFILLED_SLOT && !controlRoomStaff.includes(value) && (
                                                        <option key={value} value={value}>{value} (Old)</option>
                                                    )}
                                                </select>
                                            </td>
                                        );
                                    }
                                    
                                    if (isPair) {
                                         let selectClasses = baseClasses;
                                         if (isHighlighted) { selectClasses += " highlight-cell"; } 
                                         else {
                                            if (value === cell.buffer) { selectClasses += " dropdown-buffer"; } 
                                            else { selectClasses += " dropdown-permanent"; }
                                        }
                                        return (
                                            <td key={time} className="p-0">
                                                <select
                                                    value={value}
                                                    onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={selectClasses}
                                                >
                                                    <option value={cell.permanent}>{cell.permanent}</option>
                                                    <option value={cell.buffer}>{cell.buffer}</option>
                                                </select>
                                            </td>
                                        );
                                    }

                                    let inputClasses = baseClasses;
                                    if (isHighlighted) { inputClasses += " highlight-cell"; } 
                                    else if (isMissing) { inputClasses += " bg-yellow-100 text-yellow-800 font-bold"; } 
                                    else { inputClasses += " bg-gray-50 text-gray-700"; }
                                    
                                    return (
                                        <td key={time} className="p-0">
                                            <input
                                                type="text"
                                                value={value}
                                                onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                onClick={() => handleCellClick(value)}
                                                className={inputClasses}
                                                placeholder="ID"
                                                readOnly={isAutomated}
                                            />
                                        </td>
                                    );
                                })}
                            </tr>
                        </tbody>
                    </table>
                </div>
            );
            
            const FocusButton = ({ label, view, icon }) => {
                const isActive = focusView === view;
                const baseClasses = "py-2 px-3 sm:px-4 text-xs sm:text-sm rounded-md font-medium transition-all duration-200 flex items-center gap-1";
                const activeClasses = "bg-blue-600 text-white shadow-md";
                const inactiveClasses = "bg-white text-gray-600 hover:bg-gray-200";
                
                const icons = {
                    all: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>,
                    security: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12 12 0 0012 21.697z" /></svg>,
                    foyer: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                    sentry: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                };

                return (
                    <button onClick={() => setFocusView(view)} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
                        {icons[icon]}
                        <span className="hidden sm:inline">{label}</span>
                        <span className="sm:hidden">{label === 'SCR' ? 'SCR' : ''}</span>
                    </button>
                );
            };


            return (
                <div className="bg-white sm:p-6 rounded-lg shadow-lg">
                    {/* Control Bar: Hidden on Print */}
                    <div className="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4 p-2 sm:p-0 action-buttons">
                        <div className="flex items-center gap-2 date-selector">
                            <label htmlFor="roster-date-main" className="font-medium text-gray-700 text-lg">Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-main"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>
                        <div className="flex space-x-2">
                            <button
                                onClick={handlePrint}
                                disabled={loading || !rosterData}
                                className="py-2 px-4 bg-purple-600 text-white rounded-md shadow-md font-medium hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                Print Roster (Horizontal)
                            </button>
                            
                            <button
                                onClick={() => {
                                    if(window.confirm("Warning: This will wipe all manual edits in the roster grid.\n\nYour 'Daily Assignment Setup' assignments will be PRESERVED and used to regenerate the grid.\n\nContinue?")) {
                                        handleGenerateRoster(true);
                                    }
                                }}
                                disabled={loading || !dailyAssignments}
                                className="py-2 px-4 bg-red-600 text-white rounded-md shadow-md font-medium hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                Reset Grid to Setup
                            </button>
                            
                            <button
                                onClick={() => handleGenerateRoster(false)}
                                disabled={loading || !dailyAssignments}
                                title={!dailyAssignments ? "Please complete daily assignments first" : "Generate Roster (Keeps manual edits)"}
                                className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                {rosterData ? "Update (Keep Edits)" : "Generate Roster"}
                            </button>
                            
                             <button
                                onClick={handleSaveChanges}
                                disabled={loading || !isDirty}
                                className="py-2 px-4 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                            >
                                {loading ? "Saving..." : "Save Changes"}
                            </button>
                        </div>
                    </div>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4 mx-2 sm:mx-0">
                        {error}
                        <p className="text-sm mt-1">Note: Print View will still attempt to render data even with minor load errors.</p>
                    </div>}
                    {isDirty && <div className="text-yellow-700 bg-yellow-100 p-3 rounded-md mb-4 mx-2 sm:mx-0 unsaved-changes">You have unsaved changes.</div>}

                    {loading && !rosterData && <div className="text-center p-8">Loading...</div>}
                    
                    {!loading && !rosterData && (
                        <div className="text-center p-8 bg-gray-50 rounded-md">
                            <h3 className="text-xl font-medium text-gray-700">No roster generated for {selectedDate}.</h3>
                            <p className="text-gray-500 mt-2">Go to "Staff & Roster Setup" to configure the day, then click "Generate Roster".</p>
                        </div>
                    )}

                    {rosterData && (
                        <div className="space-y-6 p-2 sm:p-0">
                        
                            <div className="flex space-x-2 p-2 sm:p-0 bg-gray-100 sm:bg-transparent rounded-lg focus-buttons">
                                <FocusButton label="Show All" view="all" icon="all" />
                                <FocusButton label="SCR" view="security" icon="security" />
                                <FocusButton label="Foyer" view="foyer" icon="foyer" />
                                <FocusButton label="Sentry" view="sentry" icon="sentry" />
                            </div>
                            
                            <h2 className="text-xl font-bold mb-4 text-center hidden print:block">DAILY ROSTER - {selectedDate}</h2>
                        
                            {(focusView === 'all' || focusView === 'security') && (
                                <div className={`roster-section ${focusView !== 'all' ? 'border-t border-gray-300 pt-4' : ''}`}>
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Security Control Office</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(SECURITY_POSITIONS)}
                                        </table>
                                    </div>
                                </div>
                            )}
                            
                             {(focusView === 'all' || focusView === 'foyer') && (
                                <div className="border-t border-gray-300 pt-6 space-y-4 roster-section">
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Foyer Deployment</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(FOYER_POSITIONS)}
                                        </table>
                                    </div>
                                    
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Vertical Prowler</h3>
                                    {(() => {
                                        const teamLeaderId = (rosterData[SECURITY_POSITIONS[0]]?.[0]?.value || "").trim();
                                        const sectionIcId = (rosterData[SECURITY_POSITIONS[1]]?.[0]?.value || "").trim();
                                        const controlRoomStaff = [...new Set([teamLeaderId, sectionIcId].filter(id => id && id !== UNFILLED_SLOT && id !== ""))];
                                        
                                        return renderVerticalProwlerTable(controlRoomStaff);
                                    })()}
                                </div>
                             )}

                             {(focusView === 'all' || focusView === 'sentry') && (
                                <div className="border-t border-gray-300 pt-6 roster-section">
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Sentry Deployment / Patrol Duties</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(sentryRowsToRender)}
                                        </table>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        // --- Attach App to DOM ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

