<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Roster System (v12.9 - Compact 12H View)</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 4. Load Firebase SDKs (v10.13.1 - Stable) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            onSnapshot, 
            collection, 
            getDocs,
            deleteDoc,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

        // Set Firebase Log Level for debugging
        setLogLevel('debug');

        // --- Mock Firebase Config (REPLACED by Canvas Globals) ---
        const mockFirebaseConfig = {
          apiKey: "AIzaSyD7EdbBA4e04e6XvxnPgFdqZo_9squYMg0",
          authDomain: "shift-tracker-b7879.firebaseapp.com",
          projectId: "shift-tracker-b7879",
          storageBucket: "shift-tracker-b7879.firebasestorage.app",
          messagingSenderId: "619413261457",
          appId: "1:619413261457:web:71bb4d19745a64aAB20330",
          measurementId: "G-Q0BFJ8SBSY"
        };
        
        // --- Canvas Environment Variables (CRITICAL) ---
        // We use __firebase_config if available, otherwise fallback to mock
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : mockFirebaseConfig;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Make functions and db available globally
        window.db = db;
        window.auth = auth; 
        
        window.firebase = {
            doc,
            getDoc,
            setDoc,
            onSnapshot,
            collection,
            getDocs,
            deleteDoc,
            signInAnonymously,
            onAuthStateChanged,
            signInWithCustomToken,
            initialAuthToken
        };
    </script>
    
    <style>
        .highlight-cell {
            background-color: #FDE047; /* yellow-300 */
            border: 2px solid #F59E0B; /* amber-500 */
            color: #000;
            font-weight: bold;
        }
        /* Style for a permanent staff in a pair (Striped Blue) */
        .dropdown-permanent {
            font-weight: bold;
            color: #1D4ED8; /* blue-700 */
            background-image: linear-gradient(45deg, #EFF6FF 50%, #DBEAFE 50%);
            background-size: 8px 8px;
        }
        /* Style for a buffer staff in a pair (Solid Purple) */
        .dropdown-buffer {
            font-weight: bold;
            color: #581c87; /* purple-900 */
            background-color: #d8b4fe; /* purple-300 */
        }
        
        /* CRITICAL: Force Center Alignment for Inputs and Selects (Fixes iOS Left Align) */
        select, input {
            text-align: center !important;
            text-align-last: center !important;
            -moz-text-align-last: center !important;
        }
        
        /* --- PRINT STYLES (CRITICAL FOR USER REQUEST) --- */
        @media print {
            /* 1. Hide non-essential UI */
            header, footer, .nav-buttons, .action-buttons, .focus-buttons, .date-selector, .unsaved-changes {
                display: none !important;
            }
            
            /* 2. Force Landscape and remove unnecessary margins */
            @page {
                size: A4 landscape;
                margin: 0.5cm; /* Minimal margin */
            }
            
            /* 3. Scale everything down and remove shadows/borders */
            body {
                zoom: 80%; /* Shrink content slightly to fit more */
            }
            .min-h-screen, #root, main, .container {
                min-height: auto !important;
                padding: 0 !important;
                margin: 0 auto !important;
                width: 100% !important;
                max-width: none !important;
            }
            .shadow-md, .rounded-lg, .border {
                box-shadow: none !important;
                border: none !important;
                border-collapse: collapse !important;
            }
            
            /* 4. Optimize Table for Printing */
            .roster-section {
                break-inside: avoid; /* Prevent section from splitting across pages */
                margin-bottom: 0.5cm !important;
                padding: 0 !important;
            }
            .overflow-x-auto {
                overflow: visible !important; /* Allow table to spill naturally into print space */
            }
            .min-w-full {
                width: 100% !important;
                table-layout: fixed; /* Fix table layout for consistent column width */
            }
            
            /* ******* FIX: Widen Location Column for Print ******* */
            .min-w-full th:first-child,
            .min-w-full td:first-child {
                /* Give generous fixed width (~2.4 inches / 6cm) */
                width: 2.4in !important; 
                max-width: 2.4in !important;
                min-width: 2.4in !important;
                white-space: normal !important; /* Allow text to wrap if necessary */
                text-align: left !important; /* Align content left for better reading */
            }

            /* Ensure the text is small enough in the location column */
            .min-w-full th:first-child,
            .min-w-full td:first-child span {
                 font-size: 7.5pt !important;
            }
            /* ******* END FIX ******* */

            /* 5. Compact Table Cells */
            .p-1 {
                padding: 0.1rem !important;
            }
            .text-xs, .text-sm {
                font-size: 8pt !important;
                line-height: 1.1 !important;
            }
            
            /* 6. Sticky Header Fix (Must remove sticky behavior) */
            .sticky {
                position: static !important;
            }

            /* 7. Ensure text inputs/selects are rendered as plain text */
            input, select {
                -webkit-appearance: none !important;
                -moz-appearance: none !important;
                appearance: none !important;
                border: 0.5px solid #ccc !important;
                background-color: transparent !important;
                text-align: center !important;
                font-weight: bold;
                color: #000;
            }

            /* 8. Fix background colors for printed output */
            .dropdown-permanent, .dropdown-buffer, .highlight-cell {
                /* Use solid colors that print well */
                background-color: #E0F2FE !important; /* blue-100 */
                color: #000 !important;
                border: 0.5px solid #999 !important;
                background-image: none !important;
            }
            
            .bg-gray-100, .bg-gray-50 {
                background-color: #f7f7f7 !important; /* Light gray for headers */
            }
            .bg-white {
                background-color: white !important;
            }
            
            .highlight-cell {
                background-color: #FEF3C7 !important; /* yellow-100 */
            }
        }
        /* --- END PRINT STYLES --- */
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, createContext, useContext } = React;
        const { 
            doc, getDoc, setDoc, onSnapshot, 
            collection, getDocs, deleteDoc,
            signInAnonymously, onAuthStateChanged, 
            signInWithCustomToken, initialAuthToken
        } = window.firebase;
        const db = window.db;
        const auth = window.auth; 

        // --- Constants ---
        
        const SECURITY_POSITIONS = [
            "TEAM LEADER (I/C)", 
            "SECTION I/C"
        ];
        
        const FOYER_POSITIONS = [
            "XRAY-VISITOR",
            "FOYER-OE",
        ];
        const VERTICAL_PROWLER_POSITION = "VERTICAL PROWLER";

        const SENTRY_POSITIONS = [
            "E1", "PATROL 1", "E3", "N1 (CNB)", "PATROL 2", "OE/ STANDBY",
            "PERIMETER PROWLER (1st Half)", "PERIMETER PROWLER (2nd Half)"
        ];

        const TIME_SLOTS = [
            "2000Hrs", "2100Hrs", "2200Hrs", "2300Hrs", "2400Hrs", "0100Hrs",
            "0200Hrs", "0300Hrs", "0400Hrs", "0500Hrs", "0600Hrs", "0700Hrs"
        ];
        
        const VERTICAL_PROWLER_SLOTS = [
            "20:30", "23:00", "00:30", "03:00", "04:30", "06:30" // Corrected to 6 slots for 12 hours
        ];
        
        // --- ASSIGNMENT KEYS ---
        const SENTRY_SEQUENCE_KEYS = ["E1", "OE", "P2", "N1", "E3", "P1"];
        const FOYER_ASSIGNMENT_KEYS = ["FOYER 1", "FOYER 2"];
        const SECURITY_ASSIGNMENT_KEYS = ["TEAM LEADER (I/C)", "SECTION I/C"];

        const ASSIGNMENT_KEYS = [...SENTRY_SEQUENCE_KEYS, ...FOYER_ASSIGNMENT_KEYS, ...SECURITY_ASSIGNMENT_KEYS].sort();
        
        const UNASSIGNED_KEY = "Unassigned";
        const UNFILLED_SLOT = "---";

        const SENTRY_POSITION_SEQUENCES = {
            "E1":                             ["E1", "OE", "P2", "N1", "E3", "P1"],
            "PATROL 1":                       ["P1", "E1", "OE", "P2", "N1", "E3"],
            "E3":                             ["E3", "P1", "E1", "OE", "P2", "N1"],
            "N1 (CNB)":                       ["N1", "E3", "P1", "E1", "OE", "P2"],
            "PATROL 2":                       ["P2", "N1", "E3", "P1", "E1", "OE"],
            "OE/ STANDBY":                    ["OE", "P2", "N1", "E3", "P1", "E1"],
            "PERIMETER PROWLER (1st Half)":   ["P1", "E1", "OE", "P2", "N1", "E3"],
            "PERIMETER PROWLER (2nd Half)":   ["P2", "N1", "E3", "P1", "E1", "OE"]
        };
        
        // --- DB Collection Names ---
        const STAFF_POOL_COLLECTION = "staffPool_v7";
        const DAILY_ASSIGNMENTS_COLLECTION = "dailyAssignments_v7";
        const DAILY_ROSTER_COLLECTION = "dailyRosters_v7";

        // --- Helper: Get today's date ---
        const getTodayDate = () => {
            const today = new Date();
            const offset = today.getTimezoneOffset();
            const adjustedToday = new Date(today.getTime() - (offset*60*1000));
            return adjustedToday.toISOString().split('T')[0];
        };

        // --- CRITICAL: Helper to sanitize data for Firestore ---
        const sanitizeForFirestore = (obj) => {
            if (obj === undefined) return null;
            if (obj === null) return null;
            if (Array.isArray(obj)) {
                return obj.map(sanitizeForFirestore);
            }
            if (typeof obj === 'object') {
                const newObj = {};
                Object.keys(obj).forEach(key => {
                    newObj[key] = sanitizeForFirestore(obj[key]);
                });
                return newObj;
            }
            return obj;
        };
        
        // --- React Context for Staff Pool ---
        const StaffContext = createContext();
        
        function StaffProvider({ children }) {
            const [staffPool, setStaffPool] = useState([]); 
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            
            useEffect(() => {
                // Ensure db is available before attempting to connect
                if (!db) {
                     console.error("Firestore DB not initialized.");
                     setError("Database connection failed during staff load.");
                     setLoading(false);
                     return;
                }
                const staffCollectionRef = collection(db, STAFF_POOL_COLLECTION);
                const unsubscribe = onSnapshot(staffCollectionRef, (querySnapshot) => {
                    const pool = [];
                    querySnapshot.forEach(doc => {
                        pool.push({
                            id: doc.data().id,
                            type: doc.data().type || 'permanent'
                        });
                    });
                    setStaffPool(pool.sort((a, b) => a.id.localeCompare(b.id)));
                    setLoading(false);
                }, (err) => {
                    console.error("Error fetching staff pool: ", err);
                    setError("Could not load staff pool.");
                    setLoading(false);
                });
                return () => unsubscribe();
            }, []);
            
            const staffTypeMap = useMemo(() => {
                const map = new Map();
                staffPool.forEach(staff => {
                    map.set(staff.id, staff.type);
                });
                return map;
            }, [staffPool]);

            const value = { staffPool, staffTypeMap, loading, error };
            
            return (
                <StaffContext.Provider value={value}>
                    {children}
                </StaffContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const [view, setView] = useState('roster'); // roster, settings
            const [userId, setUserId] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [authError, setAuthError] = useState(null);
            const [selectedDate, setSelectedDate] = useState(getTodayDate());

            useEffect(() => {
                if (!auth) {
                    setAuthError("Authentication service is unavailable.");
                    setAuthLoading(false);
                    return;
                }
                
                // Use a local state to ensure we only try to sign in once
                let isSigningIn = false;
                
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                        setAuthLoading(false);
                    } else if (!isSigningIn) {
                        isSigningIn = true;
                        const signIn = async () => {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                    console.log("Signed in with custom token.");
                                } else {
                                    await signInAnonymously(auth);
                                    console.log("Signed in anonymously.");
                                }
                            } catch (err) {
                                console.error("Authentication error: ", err);
                                setAuthError("Failed to authenticate.");
                            } finally {
                                setAuthLoading(false);
                            }
                        };
                        signIn();
                    }
                });
                
                return () => unsubscribe();
            }, []); // Dependency array is empty to run once on mount

            if (authLoading) return <div className="p-8 text-center text-xl font-semibold">Connecting...</div>
            if (authError) return <div className="p-8 text-center text-xl font-semibold text-red-600">{authError}</div>
            if (!userId) return <div className="p-8 text-center text-xl font-semibold">Authenticating...</div>

            return (
                <StaffProvider>
                    <div className="min-h-screen">
                        {/* Header: Hidden on Print */}
                        <header className="bg-white shadow-md">
                            <nav className="container mx-auto px-4 sm:px-6 lg:px-8 flex flex-col sm:flex-row justify-between items-center py-4 gap-4">
                                <h1 className="text-2xl font-bold text-blue-600">Direct Assign Roster (v12.9)</h1>
                                <div className="flex space-x-2 nav-buttons">
                                    <NavButton
                                        label="Daily Roster"
                                        isActive={view === 'roster'}
                                        onClick={() => setView('roster')}
                                    />
                                    <NavButton
                                        label="Staff & Roster Setup"
                                        isActive={view === 'settings'}
                                        onClick={() => setView('settings')}
                                    />
                                </div>
                            </nav>
                        </header>
                        
                        {/* Page Content */}
                        <main className="container mx-auto p-0 sm:p-6 lg:px-8">
                            {view === 'roster' && <RosterView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                            {view === 'settings' && <StaffAndRosterSetupView selectedDate={selectedDate} setSelectedDate={setSelectedDate} />}
                        </main>
                        
                        {/* Footer: Hidden on Print */}
                        <footer className="text-center p-4 text-gray-500 text-sm">
                            User ID: <span className="font-mono bg-gray-200 px-1 rounded">{userId}</span>
                        </footer>
                    </div>
                </StaffProvider>
            );
        }

        function NavButton({ label, isActive, onClick }) {
            const baseClasses = "py-2 px-4 rounded-md font-medium text-sm sm:text-base transition-all duration-200";
            const activeClasses = "bg-blue-600 text-white shadow-md";
            const inactiveClasses = "text-gray-600 hover:bg-gray-200";
            return ( <button onClick={onClick} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>{label}</button> );
        }

        // --- View 1: Staff & Roster Setup (Combined) ---
        function StaffAndRosterSetupView({ selectedDate, setSelectedDate }) {
            const { staffPool, loading: staffLoading, error: staffError } = useContext(StaffContext);
            const [newStaffId, setNewStaffId] = useState("");
            const [newStaffType, setNewStaffType] = useState("permanent"); 
            
            const handleAddStaff = async () => {
                const id = newStaffId.trim();
                if (id && !staffPool.find(s => s.id === id)) {
                    try {
                        const staffDocRef = doc(db, STAFF_POOL_COLLECTION, id);
                        await setDoc(staffDocRef, { id: id, type: newStaffType });
                        setNewStaffId("");
                    } catch (err) {
                        console.error("Error adding staff: ", err);
                    }
                }
            };
            
            const handleRemoveStaff = async (id) => {
                if (confirm(`Are you sure you want to remove staff ID ${id}? This is permanent.`)) {
                    try {
                        const staffDocRef = doc(db, STAFF_POOL_COLLECTION, id);
                        await deleteDoc(staffDocRef);
                    } catch (err) {
                        console.error("Error removing staff: ", err);
                    }
                }
            };

            return (
                <div className="space-y-6">
                    {/* Section 1: Manage Staff Pool */}
                    <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                        <h2 className="text-xl font-bold mb-4 text-gray-800">1. Manage Staff Pool</h2>
                        {staffError && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{staffError}</div>}
                        
                        <div className="flex flex-col sm:flex-row gap-2 mb-4">
                            <input
                                type="text"
                                value={newStaffId}
                                onChange={(e) => setNewStaffId(e.target.value)}
                                className="flex-grow p-2 border border-gray-300 rounded-md shadow-sm"
                                placeholder="Enter new Staff ID"
                            />
                            <select 
                                value={newStaffType}
                                onChange={(e) => setNewStaffType(e.target.value)}
                                className="p-2 border border-gray-300 rounded-md shadow-sm bg-white"
                            >
                                <option value="permanent">Permanent</option>
                                <option value="buffer">Buffer</option>
                            </select>
                            <button onClick={handleAddStaff} className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700">Add Staff</button>
                        </div>
                        
                        <div className="flex flex-wrap gap-2">
                            {staffLoading && <p>Loading Staff...</p>}
                            {staffPool.map(staff => (
                                <div key={staff.id} className="flex items-center p-2 bg-gray-100 rounded-md border gap-2">
                                    <span className="font-medium text-gray-900">{staff.id}</span>
                                    <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                                        staff.type === 'buffer' ? 'bg-purple-200 text-purple-800' : 'bg-blue-200 text-blue-800'
                                    }`}>
                                        {staff.type}
                                    </span>
                                    <button onClick={() => handleRemoveStaff(staff.id)} className="ml-1 text-red-500 hover:text-red-700 font-bold">X</button>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    {/* Section 2: Daily Setup */}
                    <DailySequenceAssignment selectedDate={selectedDate} setSelectedDate={setSelectedDate} />
                </div>
            );
        }
        
        // --- Sub-component for Daily Sequence Assignment ---
        function DailySequenceAssignment({ selectedDate, setSelectedDate }) {
            const { staffPool, staffTypeMap, loading: staffLoading } = useContext(StaffContext);
            const [sequenceMap, setSequenceMap] = useState({});
            const [locationBufferMap, setLocationBufferMap] = useState({});
            const [loading, setLoading] = useState(true);
            const [status, setStatus] = useState("idle");
            const [error, setError] = useState(null);

            const allStaff = useMemo(() => staffPool, [staffPool]);
            const allAssignmentKeys = useMemo(() => ASSIGNMENT_KEYS, []);
            
            // UPDATED: Restricted List for Location Overrides
            const overrideLocations = useMemo(() => [
                "E3",
                "N1 (CNB)",
                "PATROL 1",
                "PATROL 2",
                VERTICAL_PROWLER_POSITION
            ], []);
            
            const bufferStaff = useMemo(() => staffPool.filter(s => s.type === 'buffer'), [staffPool]);

            useEffect(() => {
                if (!selectedDate || !db) return;
                setLoading(true);
                const docRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubscribe = onSnapshot(docRef, (docSnap) => {
                    
                    const defaultMap = {};
                    allAssignmentKeys.forEach(key => defaultMap[key] = []); 
                    const defaultLocMap = {};

                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        const loadedMap = data.sequenceMap || {};
                        Object.keys(loadedMap).forEach(key => {
                            if (allAssignmentKeys.includes(key)) { 
                                if (Array.isArray(loadedMap[key])) {
                                    defaultMap[key] = loadedMap[key];
                                } else if (loadedMap[key]) {
                                    defaultMap[key] = [loadedMap[key]]; // Convert string to array
                                }
                            }
                        });
                        setSequenceMap(defaultMap);
                        setLocationBufferMap(data.locationBufferMap || {});
                    } else {
                        setSequenceMap(defaultMap);
                        setLocationBufferMap({});
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading daily assignments: ", err);
                    setError("Failed to load daily assignments.");
                    setLoading(false);
                });
                
                return () => unsubscribe();
            }, [selectedDate, allAssignmentKeys]);

            // UPDATED: staffToSequenceMap now concatenates multiple assignments for multi-assigned staff (Buffers)
            const staffToSequenceMap = useMemo(() => {
                const map = {};
                for (const key of allAssignmentKeys) {
                    const staffIds = sequenceMap[key]; 
                    if (staffIds) {
                        staffIds.forEach(staffId => {
                            if (map[staffId]) {
                                map[staffId] = `${map[staffId]}, ${key}`;
                            } else {
                                map[staffId] = key;
                            }
                        });
                    }
                }
                return map;
            }, [sequenceMap, allAssignmentKeys]);

            const handleSequenceChange = (keyToAssign, staffId) => {
                setStatus("idle");
                const newMap = { ...sequenceMap };
                const staffType = staffTypeMap.get(staffId);
                
                // UPDATED: Logic for handling assignments
                // If NOT buffer, remove from previous assignment (Strict 1:1)
                // If Buffer, DO NOT remove from previous assignment (1:Many allowed)
                if (staffType !== 'buffer') {
                    // Remove from any other key first
                     allAssignmentKeys.forEach(key => {
                         if (newMap[key] && newMap[key].includes(staffId)) {
                             newMap[key] = newMap[key].filter(id => id !== staffId);
                         }
                     });
                }

                const currentIdsInSlot = newMap[keyToAssign] || [];
                
                // Add to new slot if not already there
                if (!currentIdsInSlot.includes(staffId)) {
                    newMap[keyToAssign] = [...currentIdsInSlot, staffId];
                }
                
                setSequenceMap(newMap);
            };
            
            const handleLocationBufferChange = (location, staffId) => {
                const newMap = { ...locationBufferMap };
                if (staffId === "") {
                    delete newMap[location];
                } else {
                    newMap[location] = staffId;
                }
                setLocationBufferMap(newMap);
            };

            const handleUnassign = (staffId) => {
                setStatus("idle");
                const newMap = { ...sequenceMap };
                
                // UPDATED: Completely remove staffId from ALL slots
                // This allows clearing a buffer who has multiple assignments
                allAssignmentKeys.forEach(key => {
                     if (newMap[key] && newMap[key].includes(staffId)) {
                         newMap[key] = newMap[key].filter(id => id !== staffId);
                     }
                });
                
                setSequenceMap(newMap);
            };
            
            // --- NEW: Clear All Function ---
            const handleClearAll = () => {
                if (window.confirm("Are you sure you want to CLEAR ALL assignments for this date? \n\nThis will remove all current selections. You will need to click 'Save' to persist this change.")) {
                    const emptyMap = {};
                    allAssignmentKeys.forEach(key => emptyMap[key] = []);
                    setSequenceMap(emptyMap);
                    setLocationBufferMap({});
                    setStatus("idle"); // Reset save status so user knows to save again
                }
            };

            const handleSave = async () => {
                if (!db) return setError("Database not available.");
                setStatus("saving");
                setError(null);
                try {
                    const docRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                    await setDoc(docRef, { 
                        sequenceMap: sequenceMap,
                        locationBufferMap: locationBufferMap 
                    });
                    setStatus("saved");
                    setTimeout(() => setStatus("idle"), 2000);
                } catch (err) {
                    console.error("Error saving daily setup: ", err);
                    setError("Failed to save daily setup.");
                    setStatus("error");
                }
            };
            
            const isLoading = staffLoading || loading;

            return (
                <div className="space-y-6">
                    {/* Section 1: Manage Staff Pool (Omitted for brevity in this response) */}
                    
                    {/* Section 2: Daily Setup */}
                    <div className="bg-white p-2 sm:p-6 rounded-lg shadow-lg">
                        <h2 className="text-xl font-bold mb-4 text-gray-800">2. Daily Roster Setup</h2>
                        
                        <div className="mb-6 date-selector">
                            <label htmlFor="roster-date" className="font-medium text-gray-700 text-lg">Select Date:</label>
                            <input
                                type="date"
                                id="roster-date"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg ml-2"
                            />
                        </div>
                        
                        {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4">{error}</div>}
                        
                        <p className="text-gray-600 mb-4">
                            Assign a role to each staff member.
                            <span className="font-medium text-blue-600">Sentry</span>, 
                            <span className="font-medium text-green-600"> Foyer</span>,
                            and <span className="font-medium text-orange-600"> Security Control</span>
                            roles are now used for automation.
                        </p>
                        
                        {isLoading && <p>Loading...</p>}
                        {!isLoading && (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {/* Staff assignment dropdowns (Omitted for brevity in this response) */}
                                {allStaff.length === 0 && <p className="text-gray-500 col-span-full">No staff in pool.</p>}
                                {allStaff.map(staff => {
                                    const assignedSequence = staffToSequenceMap[staff.id] || "";
                                    const staffType = staff.type;
                                    
                                    const isSentryAssignment = SENTRY_SEQUENCE_KEYS.some(k => assignedSequence.includes(k));
                                    const isFoyerAssignment = FOYER_ASSIGNMENT_KEYS.some(k => assignedSequence.includes(k));
                                    const isSecurityAssignment = SECURITY_ASSIGNMENT_KEYS.some(k => assignedSequence.includes(k));
                                    
                                    let colorClass = 'bg-white';
                                    if (staffType === 'buffer' && assignedSequence) {
                                        colorClass = 'bg-purple-100 border-purple-300';
                                    }
                                    else if (isSentryAssignment) colorClass = 'bg-blue-100 border-blue-300';
                                    else if (isFoyerAssignment) colorClass = 'bg-green-100 border-green-300';
                                    else if (isSecurityAssignment) colorClass = 'bg-orange-100 border-orange-300';

                                    const isMultiple = assignedSequence.includes(',');

                                    return (
                                        <div 
                                            key={staff.id}
                                            className={`p-4 border rounded-lg flex items-center justify-between transition-all ${colorClass}`}
                                        >
                                            <div className="flex items-center gap-2">
                                                <span className="text-lg font-medium text-gray-900">{staff.id}</span>
                                                {staff.type === 'buffer' && (
                                                    <span className="text-xs font-semibold px-2 py-0.5 rounded-full bg-purple-200 text-purple-800">
                                                        {staff.type}
                                                    </span>
                                                )}
                                            </div>
                                            <select
                                                value={assignedSequence}
                                                onChange={(e) => {
                                                    const newKey = e.target.value;
                                                    if (newKey === "") {
                                                        handleUnassign(staff.id);
                                                    } else {
                                                        handleSequenceChange(newKey, staff.id);
                                                    }
                                                }}
                                                className="p-2 border border-gray-300 rounded-md shadow-sm w-40 truncate"
                                            >
                                                <option value="">{UNASSIGNED_KEY}</option>
                                                
                                                {isMultiple && (
                                                    <option value={assignedSequence} disabled>{assignedSequence} (Multiple)</option>
                                                )}

                                                {allAssignmentKeys.map(key => {
                                                    const staffIdsInSlot = sequenceMap[key] || [];
                                                    const isThisStaffInSlot = staffIdsInSlot.includes(staff.id);
                                                    
                                                    let isDisabled = false;
                                                    if (!isThisStaffInSlot && staffIdsInSlot.length > 0) {
                                                        const typesInSlot = staffIdsInSlot.map(id => staffTypeMap.get(id));
                                                        
                                                        if (staff.type === 'permanent' || !staff.type) {
                                                            isDisabled = true;
                                                        } else if (staff.type === 'buffer') {
                                                            if (typesInSlot.includes('buffer')) {
                                                                isDisabled = true;
                                                            }
                                                            if (staffIdsInSlot.length >= 2) {
                                                                 isDisabled = true;
                                                            }
                                                        }
                                                    }
                                                    
                                                    return (
                                                        <option key={key} value={key} disabled={isDisabled} className="truncate">
                                                            {key} {staffIdsInSlot.length > 0 ? `(taken by ${staffIdsInSlot.join(', ')})` : ""}
                                                        </option>
                                                    );
                                                })}
                                            </select>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        
                        {/* --- NEW: Section 3 Location Overrides (Omitted for brevity in this response) --- */}
                        <div className="mt-8 border-t pt-6">
                            <h3 className="text-lg font-bold mb-4 text-gray-800">3. Buffer Location Override (Whole Shift)</h3>
                            <p className="text-gray-600 mb-4 text-sm">
                                Select a Buffer staff to cover an entire location (Row) for the whole night (20:00 - 07:00). 
                                Only E3, N1, Patrol 1, Patrol 2, and Vertical Prowler are available for this function.
                            </p>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 bg-gray-50 p-4 rounded-lg border">
                                 {overrideLocations.map(loc => (
                                     <div key={loc} className="flex flex-col gap-1">
                                         <label className="text-xs font-bold text-gray-600 uppercase">{loc}</label>
                                         <select
                                            value={locationBufferMap[loc] || ""}
                                            onChange={(e) => handleLocationBufferChange(loc, e.target.value)}
                                            className={`p-2 border border-gray-300 rounded-md text-sm ${locationBufferMap[loc] ? 'bg-purple-100 border-purple-400 text-purple-900 font-bold' : 'bg-white'}`}
                                         >
                                             <option value="">-- No Buffer Override --</option>
                                             {bufferStaff.map(b => (
                                                 <option key={b.id} value={b.id}>{b.id}</option>
                                             ))}
                                         </select>
                                     </div>
                                 ))}
                            </div>
                        </div>
                        
                        <div className="flex justify-end items-center gap-4 mt-6 border-t pt-4 action-buttons">
                            {/* Clear All Button */}
                            <button
                                onClick={handleClearAll}
                                disabled={status === 'saving' || isLoading}
                                className="py-2 px-4 bg-red-500 text-white rounded-md shadow-md font-medium hover:bg-red-600 disabled:bg-gray-400"
                            >
                                Clear All
                            </button>

                            <div className="flex items-center gap-4">
                                {status === 'saved' && <span className="text-green-600">Saved!</span>}
                                {status === 'error' && <span className="text-red-600">Save failed!</span>}
                                <button
                                    onClick={handleSave}
                                    disabled={status === 'saving' || isLoading}
                                    className="py-2 px-6 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                                >
                                    {status === 'saving' ? "Saving..." : "Save Daily Assignments"}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // --- View 2: Roster View (Sequence Logic) ---
        function RosterView({ selectedDate, setSelectedDate }) {
            const { staffTypeMap } = useContext(StaffContext);
            const [rosterData, setRosterData] = useState(null);
            const [dailyAssignments, setDailyAssignments] = useState(null); 
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [isDirty, setIsDirty] = useState(false);
            
            const [highlightedId, setHighlightedId] = useState(null);
            const [focusView, setFocusView] = useState('all');
            
            // --- NEW: Print Handler ---
            const handlePrint = () => {
                window.print();
            };
            
            useEffect(() => {
                if (!selectedDate || !db) return;
                setLoading(true);
                setError(null);
                setIsDirty(false);
                setHighlightedId(null);
                setFocusView('all');

                const assignmentsDocRef = doc(db, DAILY_ASSIGNMENTS_COLLECTION, selectedDate);
                const unsubAssignments = onSnapshot(assignmentsDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setDailyAssignments(docSnap.data());
                    } else {
                        setDailyAssignments(null);
                    }
                }, (err) => {
                    console.error("Error loading assignments: ", err);
                    setError("Failed to load daily assignments.");
                });

                const rosterDocRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                const unsubRoster = onSnapshot(rosterDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const loadedGrid = docSnap.data().rosterGrid || {};
                        const newRosterData = {};
                        Object.keys(loadedGrid).forEach(pos => {
                            if(Array.isArray(loadedGrid[pos])) {
                                newRosterData[pos] = loadedGrid[pos].map(cell => {
                                    if (typeof cell === 'string' || !cell) {
                                        return { value: cell || "", isAutomated: false }; 
                                    }
                                    return cell;
                                });
                            }
                        });
                        setRosterData(newRosterData);
                    } else {
                        setRosterData(null);
                    }
                    setLoading(false);
                }, (err) => {
                    console.error("Error loading roster: ", err);
                    setError("Failed to load roster data.");
                    setLoading(false);
                });
                
                return () => {
                    unsubAssignments();
                    unsubRoster();
                };
            }, [selectedDate]);
            
            const manualStandbyRows = useMemo(() => {
                if (!rosterData) {
                    return [];
                }
                return Object.keys(rosterData)
                    .filter(key => key.startsWith("OE/ STANDBY-"))
                    .sort(); 
            }, [rosterData]);
            
            const sentryRowsToRender = useMemo(() => {
                 const sentryRows = [...SENTRY_POSITIONS];
                 const standbyRowIndex = sentryRows.indexOf("OE/ STANDBY");
                 
                 if(standbyRowIndex > -1) {
                     sentryRows.splice(standbyRowIndex + 1, 0, ...manualStandbyRows);
                 }
                 return sentryRows;
            }, [manualStandbyRows]);


            const handleGenerateRoster = async (isReset = false) => {
                setLoading(true);
                setError(null);
                
                if (!db) {
                     setError("Database not available.");
                     setLoading(false);
                     return;
                }
                
                if (!dailyAssignments || !dailyAssignments.sequenceMap || !staffTypeMap || staffTypeMap.size === 0) {
                    setError("No assignments or staff types found. Please check Setup and wait for data.");
                    setLoading(false);
                    return;
                }
                
                try {
                    const sequenceMap = dailyAssignments.sequenceMap;
                    const locationBufferMap = dailyAssignments.locationBufferMap || {};
                    
                    // If reset is true, we start with an empty grid (ignoring previous manual edits)
                    // If reset is false, we clone the current data to preserve manual edits
                    const newRosterGrid = (rosterData && !isReset) ? { ...rosterData } : {};
                    
                    const bufferAssignments = {};
                    Object.keys(sequenceMap).forEach(key => {
                        let staffIds = sequenceMap[key];
                        if (!Array.isArray(staffIds)) staffIds = staffIds ? [staffIds] : [];
                        
                        const bufferId = staffIds.find(id => staffTypeMap.get(id) === 'buffer');
                        if (bufferId) {
                            bufferAssignments[key] = bufferId;
                        }
                    });

                    // --- 1. SENTRY DEPLOYMENT (Omitted for brevity in this response) ---
                    SENTRY_POSITIONS.forEach(pos => {
                        const positionRoster = [];
                        const letterSequence = SENTRY_POSITION_SEQUENCES[pos]; 
                        
                        if (letterSequence) { 
                            for (let timeIndex = 0; timeIndex < TIME_SLOTS.length; timeIndex++) {
                                const sequenceIndex = timeIndex % 6;
                                const sequenceKey = letterSequence[sequenceIndex];
                                
                                let idsInSlot = sequenceMap[sequenceKey];
                                if (!Array.isArray(idsInSlot)) idsInSlot = idsInSlot ? [idsInSlot] : [];

                                const permanentStaff = idsInSlot.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                                const bufferStaff = idsInSlot.find(id => staffTypeMap.get(id) === 'buffer');
                                
                                const oldCellData = (newRosterGrid[pos] && newRosterGrid[pos][timeIndex]) ? newRosterGrid[pos][timeIndex] : {};
                                
                                if (bufferStaff && permanentStaff !== UNFILLED_SLOT) {
                                    positionRoster.push({
                                        isAutomated: true,
                                        permanent: permanentStaff,
                                        buffer: bufferStaff,
                                        value: (oldCellData.value === permanentStaff || oldCellData.value === bufferStaff) ? oldCellData.value : permanentStaff,
                                        isPair: true
                                    });
                                } else {
                                    const onlyStaff = idsInSlot[0] || UNFILLED_SLOT;
                                    positionRoster.push({
                                        isAutomated: true,
                                        permanent: permanentStaff, 
                                        buffer: bufferStaff || null, // SAFE NULL
                                        value: onlyStaff,
                                        isPair: false
                                    });
                                }
                            }
                            newRosterGrid[pos] = positionRoster;
                        }
                    });

                    // --- 2. FOYER DEPLOYMENT (Omitted for brevity in this response) ---
                    let foyer1_ids = sequenceMap["FOYER 1"];
                    if (!Array.isArray(foyer1_ids)) foyer1_ids = foyer1_ids ? [foyer1_ids] : [];
                    
                    let foyer2_ids = sequenceMap["FOYER 2"];
                    if (!Array.isArray(foyer2_ids)) foyer2_ids = foyer2_ids ? [foyer2_ids] : [];

                    const staffA_perm = foyer1_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffA_buff = foyer1_ids.find(id => staffTypeMap.get(id) === 'buffer');
                    const staffB_perm = foyer2_ids.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const staffB_buff = foyer2_ids.find(id => staffTypeMap.get(id) === 'buffer');

                    const xraySequence = [];
                    const foyerOESequence = [];
                    
                    for (let i = 0; i < 12; i++) {
                        const isSlotA = !((i >= 3 && i <= 5) || (i >= 9));
                        
                        const permanentStaffA = isSlotA ? staffA_perm : staffB_perm;
                        const bufferStaffA = isSlotA ? staffA_buff : staffB_buff;
                        const permanentStaffB = isSlotA ? staffB_perm : staffA_perm;
                        const bufferStaffB = isSlotA ? staffB_buff : staffA_buff;
                        
                        const isPairA = bufferStaffA && permanentStaffA !== UNFILLED_SLOT;
                        const isPairB = bufferStaffB && permanentStaffB !== UNFILLED_SLOT;

                        const oldXrayCell = (newRosterGrid["XRAY-VISITOR"] && newRosterGrid["XRAY-VISITOR"][i]) ? newRosterGrid["XRAY-VISITOR"][i] : {};
                        const oldOECell = (newRosterGrid["FOYER-OE"] && newRosterGrid["FOYER-OE"][i]) ? newRosterGrid["FOYER-OE"][i] : {};
                        
                        if (isPairA) {
                            xraySequence.push({
                                isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA,
                                value: (oldXrayCell.value === permanentStaffA || oldXrayCell.value === bufferStaffA) ? oldXrayCell.value : permanentStaffA,
                                isPair: true
                            });
                        } else {
                            const onlyStaff = permanentStaffA !== UNFILLED_SLOT ? permanentStaffA : (bufferStaffA || UNFILLED_SLOT);
                            xraySequence.push({ isAutomated: true, permanent: permanentStaffA, buffer: bufferStaffA || null, value: onlyStaff, isPair: false });
                        }
                        
                        if (isPairB) {
                             foyerOESequence.push({
                                isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB,
                                value: (oldOECell.value === permanentStaffB || oldOECell.value === bufferStaffB) ? oldOECell.value : permanentStaffB,
                                isPair: true
                            });
                        } else {
                            const onlyStaff = permanentStaffB !== UNFILLED_SLOT ? permanentStaffB : (bufferStaffB || UNFILLED_SLOT);
                            foyerOESequence.push({ isAutomated: true, permanent: permanentStaffB, buffer: bufferStaffB || null, value: onlyStaff, isPair: false });
                        }
                    }

                    // --- 6-SLOT Vertical Prowler (Omitted for brevity in this response) ---
                    const existingProwlerData = newRosterGrid[VERTICAL_PROWLER_POSITION] || [];
                    
                    // Foyer OE slots are used to seed VP (Indices: 0, 2, 4, 6, 8, 10).
                    const verticalProwlerSequence = [
                        foyerOESequence[0],  // 20:30
                        foyerOESequence[2],  // 23:00 (Index 2)
                        foyerOESequence[4],  // 00:30 (Index 4)
                        foyerOESequence[6],  // 03:00 (Index 6)
                        foyerOESequence[8],  // 04:30 (Index 8)
                        foyerOESequence[10]  // 06:30 (Index 10)
                    ];
                    
                    // Clear Foyer OE slots that are taken by VP (Indices: 0, 2, 4, 6, 8, 10)
                    [0, 2, 4, 6, 8, 10].forEach(i => {
                        foyerOESequence[i] = { ...foyerOESequence[i], value: UNFILLED_SLOT, isPair: false };
                    });
                    
                    newRosterGrid["XRAY-VISITOR"] = xraySequence;
                    newRosterGrid["FOYER-OE"] = foyerOESequence;
                    
                    // Apply existing manual edit for 00:30 (VP slot index 2, which corresponds to Roster Time Index 4)
                    const vpManualIndex = 2;
                    if (existingProwlerData[vpManualIndex] && !existingProwlerData[vpManualIndex].isAutomated) {
                        verticalProwlerSequence[vpManualIndex] = existingProwlerData[vpManualIndex];
                    }

                    newRosterGrid[VERTICAL_PROWLER_POSITION] = verticalProwlerSequence.map(cell => ({...cell, isAutomated: true})); 


                    // --- 3. SECURITY CONTROL OFFICE (Omitted for brevity in this response) ---
                    let leaderIds = sequenceMap["TEAM LEADER (I/C)"];
                    if (!Array.isArray(leaderIds)) leaderIds = leaderIds ? [leaderIds] : [];
                    
                    let icIds = sequenceMap["SECTION I/C"];
                    if (!Array.isArray(icIds)) icIds = icIds ? [icIds] : [];

                    const teamLeaderId = leaderIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const sectionIcId = icIds.find(id => (staffTypeMap.get(id) === 'permanent' || !staffTypeMap.get(id))) || UNFILLED_SLOT;
                    const bufferLeader = leaderIds.find(id => staffTypeMap.get(id) === 'buffer');
                    const bufferIc = icIds.find(id => staffTypeMap.get(id) === 'buffer');
                    
                    const isPairLeader = bufferLeader && teamLeaderId !== UNFILLED_SLOT;
                    const isPairIc = bufferIc && sectionIcId !== UNFILLED_SLOT;
                    
                    newRosterGrid["TEAM LEADER (I/C)"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["TEAM LEADER (I/C)"] && newRosterGrid["TEAM LEADER (I/C)"][i]) ? newRosterGrid["TEAM LEADER (I/C)"][i] : {};
                        if (isPairLeader) {
                            return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader, value: (oldCell.value === teamLeaderId || oldCell.value === bufferLeader) ? oldCell.value : teamLeaderId, isPair: true };
                        }
                        const onlyStaff = teamLeaderId !== UNFILLED_SLOT ? teamLeaderId : (bufferLeader || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: teamLeaderId, buffer: bufferLeader || null, value: onlyStaff, isPair: false };
                    });
                    newRosterGrid["SECTION I/C"] = Array(TIME_SLOTS.length).fill(null).map((_, i) => {
                        const oldCell = (newRosterGrid["SECTION I/C"] && newRosterGrid["SECTION I/C"][i]) ? newRosterGrid["SECTION I/C"][i] : {};
                        if (isPairIc) {
                            return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc, value: (oldCell.value === sectionIcId || oldCell.value === bufferIc) ? oldCell.value : sectionIcId, isPair: true };
                        }
                        const onlyStaff = sectionIcId !== UNFILLED_SLOT ? sectionIcId : (bufferIc || UNFILLED_SLOT);
                        return { isAutomated: true, permanent: sectionIcId, buffer: bufferIc || null, value: onlyStaff, isPair: false };
                    });
                    
                    // --- 4. APPLY LOCATION BUFFER OVERRIDES (Omitted for brevity in this response) ---
                    if (locationBufferMap && Object.keys(locationBufferMap).length > 0) {
                        Object.entries(locationBufferMap).forEach(([location, bufferId]) => {
                             if (newRosterGrid[location]) {
                                 newRosterGrid[location] = newRosterGrid[location].map((cell, index) => {
                                     const permanentStaff = cell.permanent || (cell.value !== bufferId ? cell.value : UNFILLED_SLOT);
                                     
                                     if (permanentStaff !== UNFILLED_SLOT && permanentStaff !== "") {
                                         return {
                                             ...cell,
                                             permanent: permanentStaff,
                                             buffer: bufferId,
                                             isPair: true,
                                             isAutomated: true,
                                             value: permanentStaff 
                                         };
                                     } else {
                                         return {
                                             ...cell,
                                             permanent: UNFILLED_SLOT, 
                                             buffer: bufferId,
                                             isPair: false, 
                                             value: bufferId,
                                             isAutomated: true
                                         }
                                     }
                                 });
                             }
                        });
                    }
                    
                    // NEW: Sanitize before saving
                    const finalRosterGrid = sanitizeForFirestore(newRosterGrid);

                    const docRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                    // FIX: Removed { merge: true } to ensure manual rows (deleted ones) are actually removed from DB
                    await setDoc(docRef, { 
                        rosterGrid: finalRosterGrid,
                        updatedAt: new Date().toISOString(),
                    });
                    
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                         setRosterData(docSnap.data().rosterGrid || {});
                    }
                    
                    setIsDirty(false);
                    setLoading(false);
                    
                } catch (err) {
                    console.error("Error generating roster:", err);
                    setError("Failed to generate roster. Check console and security rules.");
                    setLoading(false);
                }
            };
            
            const handleSaveChanges = async () => {
                if (!rosterData || !isDirty) return;
                if (!db) return setError("Database not available.");
                setLoading(true);
                setError(null);
                try {
                    const cleanRosterData = { ...rosterData };
                    const allKeys = Object.keys(cleanRosterData);
                    
                    const existingRows = [
                        ...SECURITY_POSITIONS,
                        ...FOYER_POSITIONS,
                        VERTICAL_PROWLER_POSITION,
                        ...SENTRY_POSITIONS,
                        ...manualStandbyRows
                    ];
                    
                    allKeys.forEach(key => {
                        if (!existingRows.includes(key) && key.startsWith("OE/ STANDBY-")) {
                           delete cleanRosterData[key];
                        }
                    });

                    const finalCleanData = sanitizeForFirestore(cleanRosterData);

                    const docRef = doc(db, DAILY_ROSTER_COLLECTION, selectedDate);
                    // FIX: Removed { merge: true } to ensure manual rows (deleted ones) are actually removed from DB
                    await setDoc(docRef, { 
                        rosterGrid: finalCleanData,
                        updatedAt: new Date().toISOString()
                    });
                    setIsDirty(false);
                    setLoading(false);
                } catch (err) {
                    console.error("Error saving changes: ", err);
                    setError("Failed to save changes.");
                    setLoading(false);
                }
            };

            const handleCellChange = (position, timeIndex, newValue) => {
                setRosterData(prevRoster => {
                    const newRoster = { ...prevRoster };
                    
                    if (!newRoster[position]) {
                        newRoster[position] = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                    }
                    if (!newRoster[position][timeIndex]) {
                         newRoster[position][timeIndex] = { value: "", isAutomated: false };
                    }
                    
                    const cell = newRoster[position][timeIndex];
                    const oldValue = cell.value;
                    
                    newRoster[position][timeIndex] = { ...cell, value: newValue };
                    
                    const permanentId = cell.permanent;
                    const bufferId = cell.buffer;
                    
                    if (cell.isPair && newValue === bufferId && oldValue === permanentId) {
                        // UPDATED: Pass timeIndex to place displaced staff in correct time slot
                        placeDisplacedStaff(newRoster, permanentId, timeIndex);
                    }
                    
                    if (cell.isPair && newValue === permanentId && oldValue === bufferId) {
                        // UPDATED: Pass timeIndex to remove displaced staff from correct time slot
                        removeDisplacedStaff(newRoster, permanentId, timeIndex);
                    }

                    return newRoster;
                });
                setIsDirty(true);
            };
            
            // UPDATED: Added timeIndex param to ensure placement in correct column
            const placeDisplacedStaff = (roster, staffId, timeIndex) => {
                const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                allRows.sort((a, b) => {
                    if (a === "OE/ STANDBY") return -1;
                    if (b === "OE/ STANDBY") return 1;
                    const numA = parseInt(a.split('-')[1] || 999);
                    const numB = parseInt(b.split('-')[1] || 999);
                    return numA - numB;
                });
                
                for (const rowName of allRows) {
                    const row = roster[rowName];
                    // UPDATED: Check ONLY the specific timeIndex, do not loop through all slots
                    if (row && row[timeIndex]) {
                        const cell = row[timeIndex];
                        if (!cell.value || cell.value === UNFILLED_SLOT || cell.value === "") {
                            if (rowName === "OE/ STANDBY") {
                                roster[rowName][timeIndex] = { ...cell, value: staffId, isDisplaced: true };
                            } else {
                                roster[rowName][timeIndex] = { value: staffId, isAutomated: false };
                            }
                            return;
                        }
                    }
                }
                
                let nextNum = 2;
                while (roster[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                const newRow = Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }));
                // UPDATED: Place at specific timeIndex in new row
                newRow[timeIndex] = { value: staffId, isAutomated: false };
                roster[newRowName] = newRow;
            };

            // UPDATED: Added timeIndex param to ensure removal from correct column
            const removeDisplacedStaff = (roster, staffId, timeIndex) => {
                 const allRows = Object.keys(roster).filter(key => key.startsWith("OE/ STANDBY"));
                 
                 for (const rowName of allRows) {
                    const row = roster[rowName];
                    if (row && row[timeIndex]) {
                         const cell = row[timeIndex];
                         // UPDATED: Check ONLY the specific timeIndex
                         if (cell.value === staffId) {
                             if (rowName === "OE/ STANDBY") {
                                roster[rowName][timeIndex] = { ...cell, value: cell.permanent || UNFILLED_SLOT, isDisplaced: false };
                            } else {
                                roster[rowName][timeIndex] = { ...cell, value: "" };
                            }
                            return;
                        }
                    }
                 }
            };

            
            const handleCellClick = (value) => {
                if (!value || value === UNFILLED_SLOT) {
                    setHighlightedId(null);
                    return;
                }
                if (value === highlightedId) {
                    setHighlightedId(null);
                } else {
                    setHighlightedId(value);
                }
            };
            
            const handleAddStandbyRow = () => {
                let nextNum = 2;
                while (rosterData[`OE/ STANDBY-${nextNum}`]) {
                    nextNum++;
                }
                const newRowName = `OE/ STANDBY-${nextNum}`;
                
                setRosterData(prevData => ({
                    ...prevData,
                    [newRowName]: Array(TIME_SLOTS.length).fill(null).map(() => ({ value: "", isAutomated: false }))
                }));
                setIsDirty(true);
            };

            const handleRemoveStandbyRow = (rowName) => {
                if (confirm(`Are you sure you want to remove the row "${rowName}"?`)) {
                    setRosterData(prevData => {
                        const newData = { ...prevData };
                        delete newData[rowName]; 
                        return newData;
                    });
                    setIsDirty(true);
                }
            };
            
            const renderTableBody = (positions) => {
                return (
                    <tbody className="bg-white divide-y divide-gray-200">
                        {positions.map(pos => {
                            const isProwlerRow = pos.startsWith("PERIMETER PROWLER");
                            const isManualStandbyRow = pos.startsWith("OE/ STANDBY-");
                            
                            // --- NEW: Display Name Logic for Sentry View ---
                            let displayName = pos;
                            if (focusView === 'sentry') {
                                if (pos === "PERIMETER PROWLER (1st Half)") {
                                    displayName = "1st Half";
                                } else if (pos === "PERIMETER PROWLER (2nd Half)") {
                                    displayName = "2nd Half";
                                } else if (pos === "PATROL 1") {
                                    displayName = "P1";
                                } else if (pos === "PATROL 2") {
                                    displayName = "P2";
                                } else if (pos === "N1 (CNB)") {
                                    displayName = "N1";
                                } else if (pos === "OE/ STANDBY") {
                                    displayName = "OE";
                                } else if (pos.startsWith("OE/ STANDBY-")) {
                                    displayName = pos.replace("OE/ STANDBY", "OE");
                                }
                            }
                            
                            return (
                                <tr key={pos} className={`${
                                    isProwlerRow ? 'bg-gray-100' : 
                                    isManualStandbyRow ? 'bg-purple-50' : 'bg-white'
                                } hover:bg-gray-200`}>
                                    
                                    <td className={`sticky left-0 p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r ${
                                        isProwlerRow ? 'bg-gray-100' : 
                                        isManualStandbyRow ? 'bg-purple-50' : 'bg-white'
                                    }`}>
                                        <div className="flex items-center justify-between">
                                            <span>{displayName}</span>
                                            
                                            {pos === "OE/ STANDBY" && (
                                                <button 
                                                    onClick={handleAddStandbyRow}
                                                    className="ml-2 w-5 h-5 flex items-center justify-center bg-green-500 text-white rounded-full font-bold hover:bg-green-600 print-hidden"
                                                    title="Add manual standby row"
                                                >
                                                    +
                                                </button>
                                            )}
                                            
                                            {isManualStandbyRow && (
                                                <button 
                                                    onClick={() => handleRemoveStandbyRow(pos)}
                                                    className="ml-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white rounded-full font-bold hover:bg-red-600 print-hidden"
                                                    title={`Remove row ${pos}`}
                                                >
                                                    -
                                                </button>
                                            )}
                                        </div>
                                    </td>
                                    
                                    {TIME_SLOTS.map((time, index) => {
                                        const cell = (rosterData[pos] && rosterData[pos][index]) ? rosterData[pos][index] : { value: "", isAutomated: isManualStandbyRow ? false : true };
                                        const value = cell.value;
                                        const isAutomated = cell.isAutomated;
                                        const isPair = cell.isPair;
                                        
                                        const isMissing = isAutomated && value === UNFILLED_SLOT;
                                        const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";

                                        const getCellClasses = () => {
                                            let baseClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                            if (isHighlighted) {
                                                return baseClasses + " highlight-cell"; 
                                            }
                                            if (isMissing) {
                                                return baseClasses + " bg-yellow-100 text-yellow-800 font-bold";
                                            }
                                            if (isManualStandbyRow) {
                                                return baseClasses + " bg-purple-50";
                                            }
                                            if (isPair) {
                                                if (value === cell.buffer) {
                                                    return baseClasses + " dropdown-buffer";
                                                }
                                                return baseClasses + " dropdown-permanent";
                                            }
                                            if (isAutomated) {
                                                return baseClasses + (isProwlerRow ? ' bg-gray-100 text-gray-700' : ' bg-gray-50 text-gray-700');
                                            }
                                            return baseClasses + " bg-white";
                                        };
                                        
                                        if (isPair) {
                                            return (
                                                <td key={time} className="p-0">
                                                    <select
                                                        value={value}
                                                        onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                        onClick={() => handleCellClick(value)}
                                                        className={getCellClasses()}
                                                    >
                                                        <option value={cell.permanent}>{cell.permanent}</option>
                                                        <option value={cell.buffer}>{cell.buffer}</option>
                                                    </select>
                                                </td>
                                            );
                                        }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <input
                                                    type="text"
                                                    value={value}
                                                    onChange={(e) => handleCellChange(pos, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={getCellClasses()}
                                                    placeholder="ID"
                                                    readOnly={isAutomated && !isManualStandbyRow}
                                                />
                                            </td>
                                        );
                                    })}
                                </tr>
                            );
                        })}
                    </tbody>
                );
            };

            const renderTableHeader = (customSlots = TIME_SLOTS) => (
                <thead className="bg-gray-100">
                    <tr>
                        <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                        {customSlots.map(time => (
                            <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap">{time}</th>
                        ))}
                    </tr>
                </thead>
            );

            const renderVerticalProwlerTable = (controlRoomStaff = []) => (
                <div className="overflow-x-auto shadow-md rounded-lg border roster-section">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-100">
                            <tr>
                                <th className="sticky left-0 bg-gray-100 p-1 text-left text-xs font-bold text-gray-600 uppercase tracking-wider z-10">Location/Call-Sign</th>
                                {VERTICAL_PROWLER_SLOTS.map(time => (
                                    <th key={time} className="p-1 text-center text-xs font-bold text-gray-600 uppercase tracking-wider whitespace-nowrap">{time}</th>
                                ))}
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            <tr className="hover:bg-gray-50">
                                <td className="sticky left-0 bg-white p-2 text-sm font-medium text-gray-800 whitespace-nowrap z-10 border-r">{VERTICAL_PROWLER_POSITION}</td>
                                {VERTICAL_PROWLER_SLOTS.map((time, index) => {
                                    const cell = (rosterData[VERTICAL_PROWLER_POSITION] && rosterData[VERTICAL_PROWLER_POSITION][index]) ? rosterData[VERTICAL_PROWLER_POSITION][index] : { value: "", isAutomated: false };
                                    const value = cell.value;
                                    const isMissing = value === UNFILLED_SLOT;
                                    const isHighlighted = highlightedId && value === highlightedId && value !== UNFILLED_SLOT && value !== "";
                                    const isPair = cell.isPair;
                                    const isAutomated = cell.isAutomated;

                                    // Only VP Slot 2 (00:30) is editable by selection
                                    if (index === 2) { 
                                        let selectClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                        if (isHighlighted) {
                                            selectClasses += " highlight-cell";
                                        } else if (isMissing) {
                                            selectClasses += " bg-yellow-100 text-yellow-800 font-bold";
                                        } else {
                                            selectClasses += " bg-white";
                                        }
                                        
                                        return (
                                            <td key={time} className="p-0">
                                                <select
                                                    value={value}
                                                    onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={selectClasses}
                                                >
                                                    <option value={UNFILLED_SLOT}>{UNFILLED_SLOT}</option>
                                                    {[...new Set(controlRoomStaff)].map(id => (
                                                        <option key={id} value={id}>{id}</option>
                                                    ))}
                                                    {value && value !== UNFILLED_SLOT && !controlRoomStaff.includes(value) && (
                                                        <option key={value} value={value}>{value} (Old)</option>
                                                    )}
                                                </select>
                                            </td>
                                        );
                                    }
                                    
                                    if (isPair) {
                                         let selectClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                         if (isHighlighted) {
                                            selectClasses += " highlight-cell";
                                        } else {
                                            if (value === cell.buffer) {
                                                selectClasses += " dropdown-buffer";
                                            } else {
                                                selectClasses += " dropdown-permanent";
                                            }
                                        }
                                        return (
                                            <td key={time} className="p-0">
                                                <select
                                                    value={value}
                                                    onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                    onClick={() => handleCellClick(value)}
                                                    className={selectClasses}
                                                >
                                                    <option value={cell.permanent}>{cell.permanent}</option>
                                                    <option value={cell.buffer}>{cell.buffer}</option>
                                                </select>
                                            </td>
                                        );
                                    }

                                    let inputClasses = "w-20 p-1 text-xs sm:text-sm border-0 border-r border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none cursor-pointer text-center";
                                    if (isHighlighted) {
                                        inputClasses += " highlight-cell";
                                    } else if (isMissing) {
                                        inputClasses += " bg-yellow-100 text-yellow-800 font-bold";
                                    } else {
                                        inputClasses += " bg-gray-50 text-gray-700";
                                    }
                                    
                                    return (
                                        <td key={time} className="p-0">
                                            <input
                                                type="text"
                                                value={value}
                                                onChange={(e) => handleCellChange(VERTICAL_PROWLER_POSITION, index, e.target.value)}
                                                onClick={() => handleCellClick(value)}
                                                className={inputClasses}
                                                placeholder="ID"
                                                readOnly={isAutomated}
                                            />
                                        </td>
                                    );
                                })}
                            </tr>
                        </tbody>
                    </table>
                </div>
            );
            
            const FocusButton = ({ label, view, icon }) => {
                const isActive = focusView === view;
                const baseClasses = "py-2 px-3 sm:px-4 text-xs sm:text-sm rounded-md font-medium transition-all duration-200 flex items-center gap-1";
                const activeClasses = "bg-blue-600 text-white shadow-md";
                const inactiveClasses = "bg-white text-gray-600 hover:bg-gray-200";
                
                const icons = {
                    all: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>,
                    security: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12 12 0 0012 21.697z" /></svg>,
                    foyer: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                    sentry: <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                };

                return (
                    <button onClick={() => setFocusView(view)} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
                        {icons[icon]}
                        <span className="hidden sm:inline">{label}</span>
                        <span className="sm:hidden">{label === 'SCR' ? 'SCR' : ''}</span>
                    </button>
                );
            };


            return (
                <div className="bg-white sm:p-6 rounded-lg shadow-lg">
                    {/* Control Bar: Hidden on Print */}
                    <div className="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4 p-2 sm:p-0 action-buttons">
                        <div className="flex items-center gap-2 date-selector">
                            <label htmlFor="roster-date-main" className="font-medium text-gray-700 text-lg">Roster Date:</label>
                            <input
                                type="date"
                                id="roster-date-main"
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                className="border-gray-300 rounded-md shadow-sm p-2 text-lg"
                            />
                        </div>
                        <div className="flex space-x-2">
                            {/* NEW: Print Button */}
                            <button
                                onClick={handlePrint}
                                disabled={loading || !rosterData}
                                className="py-2 px-4 bg-purple-600 text-white rounded-md shadow-md font-medium hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                Print Roster (Horizontal)
                            </button>
                            
                            <button
                                onClick={() => {
                                    if(confirm("Warning: This will wipe all manual edits in the roster grid.\n\nYour 'Daily Roster Setup' assignments will be PRESERVED and used to regenerate the grid.\n\nContinue?")) {
                                        handleGenerateRoster(true);
                                    }
                                }}
                                disabled={loading || !dailyAssignments}
                                className="py-2 px-4 bg-red-600 text-white rounded-md shadow-md font-medium hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                Reset Grid to Setup
                            </button>
                            
                            <button
                                onClick={() => handleGenerateRoster(false)}
                                disabled={loading || !dailyAssignments}
                                title={!dailyAssignments ? "Please complete daily assignments first" : "Generate Roster (Keeps manual edits)"}
                                className="py-2 px-4 bg-green-600 text-white rounded-md shadow-md font-medium hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                {rosterData ? "Update (Keep Edits)" : "Generate Roster"}
                            </button>
                            
                             <button
                                onClick={handleSaveChanges}
                                disabled={loading || !isDirty}
                                className="py-2 px-4 bg-blue-600 text-white rounded-md shadow-md font-medium hover:bg-blue-700 disabled:bg-gray-400"
                            >
                                {loading ? "Saving..." : "Save Changes"}
                            </button>
                        </div>
                    </div>
                    
                    {error && <div className="text-red-600 bg-red-100 p-3 rounded-md mb-4 mx-2 sm:mx-0">
                        {error}
                        <p className="text-sm mt-1">Note: Print View will still attempt to render data even with minor load errors.</p>
                    </div>}
                    {isDirty && <div className="text-yellow-700 bg-yellow-100 p-3 rounded-md mb-4 mx-2 sm:mx-0 unsaved-changes">You have unsaved changes.</div>}

                    {loading && !rosterData && <div className="text-center p-8">Loading...</div>}
                    
                    {!loading && !rosterData && (
                        <div className="text-center p-8 bg-gray-50 rounded-md">
                            <h3 className="text-xl font-medium text-gray-700">No roster generated for {selectedDate}.</h3>
                            <p className="text-gray-500 mt-2">Go to "Staff & Roster Setup" to configure the day, then click "Generate Roster".</p>
                        </div>
                    )}

                    {rosterData && (
                        <div className="space-y-6 p-2 sm:p-0">
                        
                            {/* Focus Buttons: Hidden on Print */}
                            <div className="flex space-x-2 p-2 sm:p-0 bg-gray-100 sm:bg-transparent rounded-lg focus-buttons">
                                <FocusButton label="Show All" view="all" icon="all" />
                                <FocusButton label="SCR" view="security" icon="security" />
                                <FocusButton label="Foyer" view="foyer" icon="foyer" />
                                <FocusButton label="Sentry" view="sentry" icon="sentry" />
                            </div>
                            
                            <h2 className="text-xl font-bold mb-4 text-center hidden print:block">DAILY ROSTER - {selectedDate}</h2>
                        
                            {(focusView === 'all' || focusView === 'security') && (
                                <div className={`roster-section ${focusView !== 'all' ? 'border-t border-gray-300 pt-4' : ''}`}>
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Security Control Office</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(SECURITY_POSITIONS)}
                                        </table>
                                    </div>
                                </div>
                            )}
                            
                             {(focusView === 'all' || focusView === 'foyer') && (
                                <div className="border-t border-gray-300 pt-6 space-y-4 roster-section">
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Foyer Deployment</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(FOYER_POSITIONS)}
                                        </table>
                                    </div>
                                    
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Vertical Prowler</h3>
                                    {(() => {
                                        const teamLeaderId = (rosterData[SECURITY_POSITIONS[0]]?.[0]?.value || "").trim();
                                        const sectionIcId = (rosterData[SECURITY_POSITIONS[1]]?.[0]?.value || "").trim();
                                        const controlRoomStaff = [...new Set([teamLeaderId, sectionIcId].filter(id => id && id !== UNFILLED_SLOT && id !== ""))];
                                        
                                        return renderVerticalProwlerTable(controlRoomStaff);
                                    })()}
                                </div>
                             )}

                             {(focusView === 'all' || focusView === 'sentry') && (
                                <div className="border-t border-gray-300 pt-6 roster-section">
                                    <h3 className="text-lg font-semibold mb-2 text-gray-700 print:text-base print:font-bold print:bg-gray-200 print:p-1 print:border-b">Sentry Deployment / Patrol Duties</h3>
                                    <div className="overflow-x-auto shadow-md rounded-lg border">
                                        <table className="min-w-full divide-y divide-gray-200">
                                            {renderTableHeader()}
                                            {renderTableBody(sentryRowsToRender)}
                                        </table>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        // --- Attach App to DOM ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

